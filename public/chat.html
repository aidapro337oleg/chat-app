<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat App - Чат</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary-color: #667eea;
            --primary-dark: #5a6fd8;
            --secondary-color: #764ba2;
            --bg-color: #f5f7fa;
            --sidebar-bg: #ffffff;
            --text-color: #333333;
            --text-light: #666666;
            --text-lighter: #888888;
            --border-color: #e1e5e9;
            --message-sent: #667eea;
            --message-received: #ffffff;
            --message-text-sent: #ffffff;
            --message-text-received: #333333;
            --online-status: #4CAF50;
            --offline-status: #cccccc;
            --error-color: #f44336;
            --success-color: #4CAF50;
            --warning-color: #ff9800;
            --shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            --hover-light: rgba(0, 0, 0, 0.05);
        }

        [data-theme="dark"] {
            --primary-color: #7c93e6;
            --primary-dark: #6a7fd4;
            --secondary-color: #8a5fb5;
            --bg-color: #1a1a1a;
            --sidebar-bg: #2d2d2d;
            --text-color: #e0e0e0;
            --text-light: #a0a0a0;
            --text-lighter: #808080;
            --border-color: #404040;
            --message-sent: #667eea;
            --message-received: #404040;
            --message-text-sent: #ffffff;
            --message-text-received: #e0e0e0;
            --online-status: #4CAF50;
            --offline-status: #666666;
            --error-color: #f44336;
            --success-color: #4CAF50;
            --warning-color: #ff9800;
            --shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            --hover-light: rgba(255, 255, 255, 0.05);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            display: flex;
            overflow: hidden;
        }

        .sidebar {
            width: 350px;
            background: var(--sidebar-bg);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
        }

        .header {
            padding: 20px;
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            color: white;
            position: relative;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            position: relative;
            overflow: hidden;
        }

        .user-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .user-details {
            flex: 1;
        }

        .user-name {
            font-weight: 600;
            font-size: 1.1em;
        }

        .user-status {
            font-size: 0.8em;
            opacity: 0.8;
        }

        .header-buttons {
            display: flex;
            gap: 10px;
        }

        .icon-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .icon-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .notification-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: var(--error-color);
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 0.7em;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            background: var(--sidebar-bg);
        }

        .tab {
            flex: 1;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
            color: var(--text-light);
            position: relative;
        }

        .tab.active {
            background: var(--sidebar-bg);
            border-bottom-color: var(--primary-color);
            color: var(--primary-color);
            font-weight: 600;
        }

        .users-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .search-container {
    padding: 15px;
    border-bottom: 1px solid var(--border-color);
    background: var(--sidebar-bg);
    position: relative;
}


       .search-input {
    width: 100%;
    padding: 10px 15px;
    border: 2px solid var(--border-color);
    border-radius: 20px;
    background: var(--bg-color);
    color: var(--text-color);
    font-size: 0.9em;
    outline: none;
    transition: all 0.3s ease;
    box-sizing: border-box;
}

       .search-input:focus {
    border-color: var(--primary-color);
    box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
}
      .search-results {
    max-height: 300px;
    overflow-y: auto;
    margin-top: 10px;
    border-radius: 10px;
    background: var(--sidebar-bg);
    box-shadow: var(--shadow);
    border: 1px solid var(--border-color);
    display: none;
    position: absolute;
    left: 15px;
    right: 15px;
    z-index: 100;
    padding: 5px;
}
.search-results .user-item {
    display: flex;
    align-items: center;
    padding: 8px 10px;
    margin: 2px 0;
    background: var(--sidebar-bg);
    border-radius: 8px;
    cursor: pointer;
    border: 1px solid var(--border-color);
    transition: all 0.3s ease;
    max-width: 100%;
    overflow: hidden;
    min-height: 50px;
}

.search-results .user-item:hover {
    background: var(--hover-light);
    transform: translateX(3px);
}
.search-results .user-avatar-small {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background: var(--primary-color);
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: bold;
    font-size: 0.8em;
    flex-shrink: 0;
    margin-right: 10px;
}
.search-results .user-name-small {
    font-weight: 600;
    color: var(--text-color);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    font-size: 0.85em;
    line-height: 1.2;
}
.search-results .add-friend-btn {
    background: var(--primary-color);
    color: white;
    border: none;
    padding: 5px 8px;
    border-radius: 10px;
    cursor: pointer;
    font-size: 0.7em;
    transition: all 0.3s ease;
    white-space: nowrap;
    flex-shrink: 0;
    margin-left: 8px;
    height: fit-content;
}
.search-results .add-friend-btn:hover {
    background: var(--primary-dark);
    transform: scale(1.05);
}
.search-results .user-status-small {
    font-size: 0.7em;
    color: var(--text-light);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    line-height: 1.2;
}

.search-results .user-details-small {
    flex: 1;
    min-width: 0;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    justify-content: center;
}
.search-results .friend-status {
    color: var(--success-color);
    font-size: 0.7em;
    padding: 5px 8px;
    white-space: nowrap;
    flex-shrink: 0;
    margin-left: 8px;
    display: flex;
    align-items: center;
    gap: 4px;
}
@media (max-width: 768px) {
    .search-results {
        left: 10px;
        right: 10px;
    }
    
    .search-results .user-item {
        padding: 6px 8px;
        min-height: 45px;
    }
    
    .search-results .user-avatar-small {
        width: 28px;
        height: 28px;
        margin-right: 8px;
        font-size: 0.75em;
    }
    
    .search-results .user-name-small {
        font-size: 0.8em;
    }
    
    .search-results .user-status-small {
        font-size: 0.65em;
    }
    
    .search-results .add-friend-btn {
        padding: 4px 6px;
        font-size: 0.65em;
    }
}
        .user-item {
            padding: 12px 15px;
            margin: 5px 0;
            background: var(--sidebar-bg);
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
            gap: 10px;
        }

        .user-item:hover {
            background: var(--hover-light);
            transform: translateX(5px);
        }

        .user-item.active {
            border-left: 4px solid var(--primary-color);
            background: var(--hover-light);
        }

        .user-avatar-small {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            position: relative;
        }

        .online-status {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid var(--sidebar-bg);
            position: absolute;
            bottom: 0;
            right: 0;
        }

        .online {
            background: var(--online-status);
        }

        .offline {
            background: var(--offline-status);
        }

        .user-details-small {
            flex: 1;
        }

        .user-name-small {
            font-weight: 600;
            margin-bottom: 2px;
            color: var(--text-color);
        }

        .user-status-small {
            font-size: 0.8em;
            color: var(--text-light);
        }

        .add-friend-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.8em;
            transition: all 0.3s ease;
        }

        .add-friend-btn:hover {
            background: var(--primary-dark);
            transform: scale(1.05);
        }

        .remove-friend-btn {
            background: var(--error-color);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.8em;
            transition: all 0.3s ease;
        }

        .remove-friend-btn:hover {
            opacity: 0.8;
            transform: scale(1.05);
        }

        .chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .no-friends-view {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            text-align: center;
        }

        .no-friends-icon {
            font-size: 80px;
            color: var(--text-lighter);
            margin-bottom: 20px;
        }

        .no-friends-title {
            font-size: 24px;
            color: var(--text-color);
            margin-bottom: 10px;
        }

        .no-friends-text {
            color: var(--text-light);
            margin-bottom: 30px;
            max-width: 400px;
            line-height: 1.5;
        }

        .add-friends-btn {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .add-friends-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow);
        }

        .chat-header {
            padding: 20px;
            background: var(--sidebar-bg);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .chat-user-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .clear-chat-btn {
            background: var(--warning-color);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
            margin-left: 10px;
            display: none;
        }

        .clear-chat-btn:hover {
            opacity: 0.8;
            transform: scale(1.05);
        }

        .call-btn {
            background: var(--success-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
        }

        .call-btn:hover {
            opacity: 0.9;
            transform: scale(1.05);
        }

        .call-btn:disabled {
            background: var(--offline-status);
            cursor: not-allowed;
            transform: none;
        }

        .non-friend-banner {
            background: var(--warning-color);
            color: white;
            padding: 10px 20px;
            text-align: center;
            display: none;
            justify-content: space-between;
            align-items: center;
        }

        .non-friend-banner button {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid white;
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .non-friend-banner button:hover {
            background: white;
            color: var(--warning-color);
        }

        .messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: var(--bg-color);
            display: flex;
            flex-direction: column;
        }

        .message {
            max-width: 70%;
            padding: 12px 16px;
            margin: 5px 0;
            border-radius: 15px;
            position: relative;
            word-wrap: break-word;
        }

        .message.received {
            background: var(--message-received);
            border-bottom-left-radius: 5px;
            align-self: flex-start;
            box-shadow: var(--shadow);
            color: var(--message-text-received);
        }

        .message.sent {
            background: var(--message-sent);
            color: var(--message-text-sent);
            border-bottom-right-radius: 5px;
            margin-left: auto;
            box-shadow: var(--shadow);
        }

        .delete-message-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(0, 0, 0, 0.3);
            border: none;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7em;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .message:hover .delete-message-btn {
            opacity: 1;
        }

        .message-image {
            max-width: 100%;
            max-height: 300px;
            border-radius: 10px;
            margin-top: 5px;
            cursor: pointer;
            object-fit: contain;
        }

        .message-gif {
            max-width: 100%;
            max-height: 300px;
            border-radius: 10px;
            margin-top: 5px;
            cursor: pointer;
        }

        .message-file {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: var(--hover-light);
            border-radius: 8px;
            margin-top: 5px;
        }

        .file-icon {
            font-size: 24px;
            color: var(--primary-color);
        }

        .file-info {
            flex: 1;
        }

        .file-name {
            font-weight: 600;
            margin-bottom: 2px;
        }

        .file-size {
            font-size: 0.8em;
            color: var(--text-light);
        }

        .download-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8em;
        }

        .link-preview {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-top: 5px;
            overflow: hidden;
            max-width: 400px;
        }

        .link-preview-image {
            width: 100%;
            max-height: 200px;
            object-fit: cover;
        }

        .link-preview-content {
            padding: 10px;
        }

        .link-preview-title {
            font-weight: 600;
            margin-bottom: 5px;
            color: var(--text-color);
        }

        .link-preview-description {
            font-size: 0.9em;
            color: var(--text-light);
            margin-bottom: 5px;
        }

        .link-preview-url {
            font-size: 0.8em;
            color: var(--primary-color);
            word-break: break-all;
        }

        .message-time {
            font-size: 0.7em;
            opacity: 0.7;
            margin-top: 5px;
            text-align: right;
        }

        .message-input-container {
            padding: 20px;
            background: var(--sidebar-bg);
            border-top: 1px solid var(--border-color);
        }

        .message-input-wrapper {
            display: flex;
            align-items: flex-end;
            gap: 10px;
            background: var(--bg-color);
            border-radius: 25px;
            padding: 10px 15px;
            position: relative;
        }

        .message-actions {
            display: flex;
            gap: 5px;
        }

        .action-btn {
            background: none;
            border: none;
            color: var(--primary-color);
            font-size: 18px;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .action-btn:hover {
            background: var(--hover-light);
        }

        .message-input {
            flex: 1;
            border: none;
            background: transparent;
            outline: none;
            resize: none;
            max-height: 100px;
            padding: 5px 0;
            font-family: inherit;
            font-size: 14px;
            color: var(--text-color);
        }

        .send-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .send-btn:hover {
            background: var(--primary-dark);
            transform: scale(1.1);
        }

        .send-btn:disabled {
            background: var(--offline-status);
            cursor: not-allowed;
            transform: none;
        }

        /* Voice Message Styles */
        .voice-message {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: var(--hover-light);
            border-radius: 20px;
            margin-top: 5px;
        }

        .voice-play-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .voice-progress {
            flex: 1;
            height: 4px;
            background: var(--border-color);
            border-radius: 2px;
            position: relative;
            cursor: pointer;
        }

        .voice-progress-bar {
            position: absolute;
            height: 100%;
            background: var(--primary-color);
            border-radius: 2px;
            width: 0%;
        }

        .voice-duration {
            font-size: 0.8em;
            color: var(--text-light);
            min-width: 40px;
        }

        .voice-recorder {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--sidebar-bg);
            padding: 20px;
            border-radius: 15px;
            box-shadow: var(--shadow);
            z-index: 1000;
            display: none;
            align-items: center;
            gap: 15px;
        }

        .voice-recording {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .recording-dot {
            width: 12px;
            height: 12px;
            background: var(--error-color);
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .recording-timer {
            font-weight: 600;
            color: var(--text-color);
        }

        .recording-controls {
            display: flex;
            gap: 10px;
        }

        /* Emoji and GIF pickers */
        .emoji-picker, .gif-picker {
            position: absolute;
            bottom: 70px;
            left: 10px;
            background: var(--sidebar-bg);
            border-radius: 10px;
            box-shadow: var(--shadow);
            padding: 15px;
            z-index: 100;
            display: none;
            max-width: 300px;
            max-height: 200px;
            overflow-y: auto;
        }

        .emoji-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 5px;
        }

        .emoji {
            font-size: 1.2em;
            cursor: pointer;
            padding: 5px;
            text-align: center;
            border-radius: 5px;
        }

        .emoji:hover {
            background: var(--hover-light);
        }

        .gif-search {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background: var(--sidebar-bg);
            color: var(--text-color);
        }

        .gif-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 5px;
        }

        .gif-item img {
            width: 100%;
            border-radius: 5px;
            cursor: pointer;
        }

        /* Modal windows */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .modal-content {
            background: var(--sidebar-bg);
            border-radius: 15px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: var(--shadow);
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: between;
            align-items: center;
        }

        .modal-title {
            font-size: 1.2em;
            font-weight: 600;
        }

        .close-modal {
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            color: var(--text-color);
        }

        .modal-body {
            padding: 20px;
        }

        .settings-section {
            margin-bottom: 25px;
        }

        .settings-title {
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--primary-color);
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .setting-label {
            color: var(--text-color);
        }

        .setting-select {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background: var(--sidebar-bg);
            color: var(--text-color);
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--border-color);
            transition: .4s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: var(--primary-color);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }

        /* Call Interface Styles */
        .call-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .call-content {
            background: var(--sidebar-bg);
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            max-width: 500px;
            width: 90%;
        }

        .call-user {
            font-size: 1.5em;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .video-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 20px 0;
        }

        .call-controls {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            justify-content: center;
        }

        .call-action-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .accept-call {
            background: var(--success-color);
            color: white;
        }

        .reject-call, .end-call {
            background: var(--error-color);
            color: white;
        }

        .mute-btn, .video-btn, .screen-share-btn {
            background: #6c757d;
            color: white;
        }

        .mute-btn.active, .video-btn.active, .screen-share-btn.active {
            background: var(--primary-color);
        }

        .volume-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
        }

        .volume-slider {
            width: 100px;
        }

        .speaking-indicator {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: var(--success-color);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8em;
            display: none;
        }

        /* Avatar Selection Styles */
        .avatar-selection {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .avatar-option {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            overflow: hidden;
        }

        .avatar-option:hover {
            border-color: var(--primary-color);
        }

        .avatar-option.selected {
            border-color: var(--primary-color);
            box-shadow: 0 0 10px var(--primary-color);
        }

        .avatar-option img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Friend requests */
        .friend-request-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            margin-bottom: 10px;
        }

        .friend-request-actions {
            display: flex;
            gap: 10px;
        }

        .accept-request, .decline-request {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .accept-request {
            background: var(--success-color);
            color: white;
        }

        .decline-request {
            background: var(--error-color);
            color: white;
        }

        /* Friend management */
        .friend-management {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .friend-username-input {
            flex: 1;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background: var(--sidebar-bg);
            color: var(--text-color);
        }

        .add-friend-submit {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
        }

        /* Permission guide */
        .permission-guide {
            background: var(--hover-light);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .permission-steps {
            margin-left: 20px;
            margin-top: 10px;
        }

        .permission-steps li {
            margin-bottom: 5px;
        }

        /* Image preview modal */
        .image-preview-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .close-preview {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: white;
            font-size: 2em;
            cursor: pointer;
        }

        .image-preview-content {
            max-width: 90%;
            max-height: 90%;
        }

        .image-preview-content img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        /* Minimized call */
        .minimized-call {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--sidebar-bg);
            padding: 15px;
            border-radius: 10px;
            box-shadow: var(--shadow);
            display: none;
            align-items: center;
            gap: 15px;
            z-index: 1000;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .sidebar {
                width: 100%;
                position: absolute;
                z-index: 100;
                height: 100%;
                transform: translateX(-100%);
            }
            
            .sidebar.active {
                transform: translateX(0);
            }
            
            .message {
                max-width: 85%;
            }
            
            .call-controls {
                gap: 10px;
            }
            
            .call-action-btn {
                width: 50px;
                height: 50px;
                font-size: 1.2em;
            }
            
            .video-container {
                flex-direction: column;
            }
        }
        /* Улучшенные стили для окна звонка */
.call-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 10000;
}

.call-content {
    background: var(--sidebar-bg);
    border-radius: 20px;
    padding: 30px;
    text-align: center;
    max-width: 900px;
    width: 95%;
    max-height: 90vh;
    box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
}

.call-header {
    margin-bottom: 25px;
}

.call-user {
    font-size: 1.8em;
    font-weight: 600;
    margin-bottom: 8px;
    color: var(--text-color);
}

#callStatus {
    font-size: 1.1em;
    color: var(--text-light);
}

.video-container {
    display: grid;
    grid-template-columns: 2fr 1fr;
    gap: 20px;
    margin: 25px 0;
    align-items: start;
}

.video-wrapper {
    position: relative;
    border-radius: 15px;
    overflow: hidden;
    background: #000;
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
}

.video-wrapper.local-video {
    align-self: end;
}

.video-element {
    width: 100%;
    height: auto;
    max-height: 400px;
    object-fit: cover;
    border-radius: 15px;
}

.speaking-indicator {
    position: absolute;
    bottom: 15px;
    left: 15px;
    background: var(--success-color);
    color: white;
    padding: 8px 15px;
    border-radius: 20px;
    font-size: 0.9em;
    display: none;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
}

.volume-controls {
    display: flex;
    justify-content: center;
    gap: 30px;
    margin: 25px 0;
}

.volume-control {
    display: flex;
    align-items: center;
    gap: 12px;
    background: var(--bg-color);
    padding: 12px 20px;
    border-radius: 25px;
}

.volume-control i {
    color: var(--primary-color);
    font-size: 1.1em;
}

.volume-slider {
    width: 120px;
}

.call-controls {
    display: flex;
    gap: 15px;
    justify-content: center;
    margin-top: 20px;
}

.call-action-btn {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    border: none;
    font-size: 1.6em;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}

.call-action-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
}

.call-action-btn:active {
    transform: scale(1.05);
}

.end-call {
    background: var(--error-color);
    color: white;
}

.mute-btn, .video-btn, .screen-share-btn, .minimize-btn {
    background: #6c757d;
    color: white;
}

.mute-btn.active, .video-btn.active, .screen-share-btn.active {
    background: var(--primary-color);
}
/* Стили для улучшенного окна звонка */
.call-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.95);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    backdrop-filter: blur(10px);
}

.call-container {
    background: var(--sidebar-bg);
    border-radius: 20px;
    width: 95%;
    max-width: 1200px;
    height: 90vh;
    max-height: 800px;
    display: flex;
    flex-direction: column;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    overflow: hidden;
}

.call-header {
    padding: 25px 30px;
    border-bottom: 1px solid var(--border-color);
    text-align: center;
    background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
    color: white;
}

.call-header h2 {
    margin: 0 0 8px 0;
    font-size: 1.8em;
    font-weight: 600;
}

.call-status {
    font-size: 1.1em;
    opacity: 0.9;
}

.video-section {
    flex: 1;
    position: relative;
    background: #000;
    overflow: hidden;
}

.video-main {
    width: 100%;
    height: 100%;
    position: relative;
}

.remote-video {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.video-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.3);
}

.user-info {
    text-align: center;
    color: white;
}

.user-avatar-large {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    background: var(--primary-color);
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 0 auto 20px;
    font-size: 3em;
    font-weight: bold;
}

.user-name {
    font-size: 1.5em;
    font-weight: 600;
}

.video-pip {
    position: absolute;
    bottom: 20px;
    right: 20px;
    width: 200px;
    height: 150px;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
    border: 2px solid var(--primary-color);
}

.local-video {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.speaking-indicator {
    position: absolute;
    bottom: 15px;
    left: 15px;
    background: var(--success-color);
    color: white;
    padding: 8px 15px;
    border-radius: 20px;
    font-size: 0.9em;
    display: none;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
}

.call-controls-section {
    padding: 25px 30px;
    background: var(--sidebar-bg);
}

.volume-controls {
    display: flex;
    justify-content: center;
    gap: 40px;
    margin-bottom: 25px;
}

.volume-control {
    display: flex;
    align-items: center;
    gap: 12px;
    background: var(--bg-color);
    padding: 12px 20px;
    border-radius: 25px;
    min-width: 180px;
}

.volume-control i {
    color: var(--primary-color);
    font-size: 1.1em;
}

.volume-control span {
    font-size: 0.9em;
    color: var(--text-light);
}

.volume-slider {
    width: 80px;
}

.call-controls {
    display: flex;
    gap: 15px;
    justify-content: center;
}

.call-action-btn {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    border: none;
    font-size: 1.6em;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}

.call-action-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
}

.call-action-btn:active {
    transform: scale(1.05);
}

.end-call {
    background: var(--error-color);
    color: white;
}

.mute-btn, .video-btn, .screen-share-btn, .minimize-btn {
    background: #6c757d;
    color: white;
}

.mute-btn.active, .video-btn.active, .screen-share-btn.active {
    background: var(--primary-color);
}

/* Адаптивность для мобильных устройств */
@media (max-width: 768px) {
    .call-container {
        width: 100%;
        height: 100%;
        border-radius: 0;
    }
    
    .call-header {
        padding: 20px;
    }
    
    .video-pip {
        width: 120px;
        height: 90px;
        bottom: 10px;
        right: 10px;
    }
    
    .call-controls-section {
        padding: 20px 15px;
    }
    
    .volume-controls {
        flex-direction: column;
        gap: 15px;
        align-items: center;
    }
    
    .volume-control {
        min-width: 150px;
    }
    
    .call-action-btn {
        width: 60px;
        height: 60px;
        font-size: 1.4em;
    }
    
    .call-controls {
        gap: 10px;
    }
}
/* Стили для разделителей дат в чате */
.date-separator {
    text-align: center;
    margin: 20px 0;
    position: relative;
}

.date-separator span {
    background: var(--sidebar-bg);
    color: var(--text-light);
    padding: 6px 12px;
    border-radius: 15px;
    font-size: 0.8em;
    border: 1px solid var(--border-color);
    display: inline-block;
    position: relative;
    z-index: 2;
}

.date-separator::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    height: 1px;
    background: var(--border-color);
    z-index: 1;
}

/* Улучшенные стили для времени сообщения */
.message-time {
    font-size: 0.7em;
    opacity: 0.7;
    margin-top: 5px;
    text-align: right;
    color: var(--text-light);
}
/* Стили для аватарки в звонке */
.video-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.7);
    z-index: 10;
}

.user-avatar-large {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 3em;
    font-weight: bold;
    border: 4px solid white;
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
}

.user-name {
    color: white;
    font-size: 1.5em;
    font-weight: 600;
    margin-top: 15px;
    text-align: center;
}
/* Улучшенные стили для контейнера поиска */
.search-container {
    padding: 15px;
    border-bottom: 1px solid var(--border-color);
    background: var(--sidebar-bg);
}

.search-input {
    width: 100%;
    padding: 12px 15px;
    border: 2px solid var(--border-color);
    border-radius: 25px;
    background: var(--bg-color);
    color: var(--text-color);
    font-size: 14px;
    outline: none;
    transition: border-color 0.3s ease;
}

.search-input:focus {
    border-color: var(--primary-color);
}

.search-input::placeholder {
    color: var(--text-light);
    font-size: 0.9em;
}

.search-empty-state {
    padding: 20px 15px;
    text-align: center;
    color: var(--text-light);
}
.search-empty-state i {
    font-size: 2em;
    margin-bottom: 10px;
    opacity: 0.5;
}

.search-empty-state div {
    font-size: 0.9em;
}
/* Стили для результатов поиска */
.search-results {
    max-height: 300px;
    overflow-y: auto;
    margin-top: 10px;
    border-radius: 10px;
    background: var(--sidebar-bg);
    box-shadow: var(--shadow);
    border: 1px solid var(--border-color);
    display: none;
    position: absolute;
    left: 15px;
    right: 15px;
    z-index: 100;
}

/* Адаптивность для мобильных */
@media (max-width: 768px) {
    .search-results {
        left: 10px;
        right: 10px;
    }
}
/* Стили для предпросмотра аватарки */
.avatar-preview-container {
    text-align: center;
    margin: 15px 0;
    padding: 15px;
    background: var(--bg-color);
    border-radius: 10px;
    border: 2px dashed var(--border-color);
}

.avatar-preview {
    width: 100px;
    height: 100px;
    border-radius: 50%;
    overflow: hidden;
    margin: 0 auto;
    border: 3px solid var(--primary-color);
}

.avatar-preview img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}
/* Стили для системы вкладок */
.tab-content {
    display: none;
    flex: 1;
    overflow-y: auto;
}

.tab-content.active {
    display: block;
}

.friend-requests-container {
    padding: 10px;
    height: 100%;
    overflow-y: auto;
}

/* Убедитесь, что контейнеры поиска правильно отображаются */
.search-container {
    padding: 10px;
    border-bottom: 1px solid var(--border-color);
}
/* Адаптивность для мобильных устройств */
@media (max-width: 768px) {
    .call-content {
        padding: 20px;
        margin: 10px;
        width: calc(100% - 20px);
    }
    
    .video-container {
        grid-template-columns: 1fr;
        gap: 15px;
    }
    
    .video-wrapper.local-video {
        max-width: 200px;
        justify-self: center;
    }
    
    .video-element {
        max-height: 250px;
    }
    
    .call-action-btn {
        width: 60px;
        height: 60px;
        font-size: 1.4em;
    }
    
    .volume-controls {
        flex-direction: column;
        gap: 15px;
        align-items: center;
    }
}
        /* Notification Styles */
.notification {
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 12px 20px;
    border-radius: 8px;
    color: white;
    z-index: 10000;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    max-width: 300px;
    word-wrap: break-word;
    font-size: 14px;
    animation: slideInRight 0.3s ease;
}

.notification.success {
    background: var(--success-color);
}

.notification.error {
    background: var(--error-color);
}

.notification.warning {
    background: var(--warning-color);
}

.notification.info {
    background: var(--primary-color);
}

@keyframes slideInRight {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}
.message-input-container {
    padding: 20px;
    background: var(--sidebar-bg);
    border-top: 1px solid var(--border-color);
    position: relative;
    z-index: 10;
}

.message-input-wrapper {
    display: flex;
    align-items: flex-end;
    gap: 10px;
    background: var(--bg-color);
    border-radius: 25px;
    padding: 10px 15px;
    border: 2px solid var(--border-color);
    transition: border-color 0.3s ease;
}

.message-input-wrapper:focus-within {
    border-color: var(--primary-color);
}

.message-input {
    flex: 1;
    border: none;
    background: transparent;
    outline: none;
    resize: none;
    max-height: 120px;
    min-height: 20px;
    padding: 8px 0;
    font-family: inherit;
    font-size: 14px;
    color: var(--text-color);
    line-height: 1.4;
}

.message-input::placeholder {
    color: var(--text-light);
}

.message-input:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

/* Убедитесь, что пикеры не перекрывают поле ввода */
.emoji-picker, .gif-picker {
    position: absolute;
    bottom: 100%;
    left: 20px;
    right: 20px;
    background: var(--sidebar-bg);
    border-radius: 10px;
    box-shadow: var(--shadow);
    padding: 15px;
    z-index: 1000;
    display: none;
    max-height: 300px;
    overflow-y: auto;
    border: 1px solid var(--border-color);
}

/* Улучшенные уведомления */
.notification {
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 12px 20px;
    border-radius: 8px;
    color: white;
    z-index: 10000;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    max-width: 300px;
    word-wrap: break-word;
    font-size: 14px;
    animation: slideInRight 0.3s ease;
    backdrop-filter: blur(10px);
}

@keyframes slideInRight {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}
    </style>
</head>
<body data-theme="light">
    <!-- Боковая панель -->
    <div class="sidebar">
        <div class="header">
            <div class="user-info">
                <div class="user-avatar" id="userAvatar">
                    <img id="userAvatarImg" src="" alt="Avatar" style="display: none;">
                    <div id="userAvatarFallback">U</div>
                </div>
                <div class="user-details">
                    <div class="user-name" id="currentUserName">Загрузка...</div>
                    <div class="user-status" id="userStatus">online</div>
                </div>
                <div class="header-buttons">
                    <button class="icon-btn" onclick="openSettings()">
                        <i class="fas fa-cog"></i>
                    </button>
                    <button class="icon-btn" onclick="openFriendRequests()" id="friendRequestsBtn">
                        <i class="fas fa-user-plus"></i>
                        <div class="notification-badge" id="friendRequestsBadge" style="display: none;">0</div>
                    </button>
                    <button class="icon-btn" onclick="logout()">
                        <i class="fas fa-sign-out-alt"></i>
                    </button>
                </div>
            </div>
        </div>
        
       <div class="tabs">
    <div class="tab active" onclick="switchTab('friends')">
        <i class="fas fa-user-friends"></i> Друзья
    </div>
    <div class="tab" onclick="switchTab('search')">
        <i class="fas fa-search"></i> Поиск
    </div>
    <div class="tab" onclick="switchTab('requests')" id="requestsTab">
        <i class="fas fa-user-plus"></i> Заявки
        <div class="notification-badge" id="requestsTabBadge" style="display: none;">0</div>
    </div>
</div>
        
        <div class="search-container" id="searchContainer" style="display: none;">
    <input type="text" class="search-input" id="searchInput" placeholder="Введите username пользователя...">
    <div class="search-results" id="searchResults"></div>
</div>

        
        <div class="users-list" id="usersList">
            <!-- Users will be populated by JavaScript -->
        </div>
        
        <div id="friendRequestsContainer" style="display: none; padding: 10px;">
            <div class="friend-requests-list" id="friendRequestsList">
                <!-- Friend requests will be populated by JavaScript -->
            </div>
        </div>
    </div>
    
    <!-- Основная область чата -->
    <div class="chat-area" id="chatArea">
        <!-- Вид когда нет друзей -->
        <div id="noFriendsView" class="no-friends-view">
            <div class="no-friends-icon">
                <i class="fas fa-user-friends"></i>
            </div>
            <div class="no-friends-title">У вас пока нет друзей</div>
            <div class="no-friends-text">
                Найдите пользователей по их username и добавьте их в друзья, чтобы начать общение
            </div>
            <button class="add-friends-btn" onclick="switchTab('search')">
                <i class="fas fa-search"></i> Найти друзей
            </button>
        </div>
        
        <!-- Вид когда выбран друг для чата -->
        <div id="chatView" style="display: none; flex: 1; flex-direction: column; height: 100%;">
            <div class="chat-header">
                <div class="chat-user-info">
                    <div class="user-avatar-small" id="chatUserAvatar">
                        <div id="chatUserAvatarFallback">U</div>
                        <div class="online-status" id="chatUserStatus"></div>
                    </div>
                    <div>
                        <div id="chatWithUser">Выберите пользователя для чата</div>
                        <small id="chatUserStatusText">offline</small>
                    </div>
                </div>
                <div>
                    <button class="clear-chat-btn" id="clearChatBtn">
                        <i class="fas fa-trash"></i> Очистить чат
                    </button>
                    <button class="call-btn" id="callButton" onclick="startCall()" disabled>
                        <i class="fas fa-phone"></i> Позвонить
                    </button>
                </div>
            </div>
            
            <div id="nonFriendBanner" class="non-friend-banner">
                <span>Этот пользователь не в вашем списке друзей</span>
                <button onclick="sendFriendRequest()">Добавить в друзья</button>
            </div>
            
            <div class="messages" id="messages">
                <div style="text-align: center; color: var(--text-light); margin-top: 20px;">
                    Начните общение с этим пользователем
                </div>
            </div>
            
            <!-- ТОЛЬКО ОДИН БЛОК ВВОДА СООБЩЕНИЙ -->
            <div class="message-input-container" id="messageInputContainer">
                <div class="message-input-wrapper">
                    <div class="message-actions">
                        <button type="button" class="action-btn" onclick="toggleEmojiPicker()">
                            <i class="far fa-smile"></i>
                        </button>
                        <button type="button" class="action-btn" onclick="toggleGifPicker()">
                            <i class="fas fa-film"></i>
                        </button>
                        <button type="button" class="action-btn" onclick="startVoiceRecording()" id="voiceRecordBtn">
                            <i class="fas fa-microphone"></i>
                        </button>
                        <button type="button" class="action-btn" onclick="document.getElementById('imageInput').click()">
                            <i class="far fa-image"></i>
                        </button>
                        <button type="button" class="action-btn" onclick="document.getElementById('fileInput').click()">
                            <i class="far fa-file-alt"></i>
                        </button>
                    </div>
                    
                    <textarea class="message-input" id="messageInput" placeholder="Введите сообщение..." 
                             rows="1" oninput="autoResize(this)"></textarea>
                    
                    <button class="send-btn" onclick="sendMessage()" id="sendButton">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
           
                    
                    <div class="emoji-picker" id="emojiPicker">
                        <div class="emoji-category">
                            <div class="emoji-category-title">Смайлики</div>
                            <div class="emoji-grid" id="emojiGrid">
                                <!-- Emojis will be added by JavaScript -->
                            </div>
                        </div>
                    </div>
                    
                    <div class="gif-picker" id="gifPicker">
                        <input type="text" class="gif-search" id="gifSearch" placeholder="Поиск GIF..." oninput="searchGifs()">
                        <div class="gif-grid" id="gifGrid">
                            <!-- GIFs will be populated by JavaScript -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Голосовой рекордер -->
    <div class="voice-recorder" id="voiceRecorder">
        <div class="voice-recording">
            <div class="recording-dot"></div>
            <div class="recording-timer" id="recordingTimer">00:00</div>
        </div>
        <div class="recording-controls">
            <button class="icon-btn" onclick="sendVoiceMessage()" style="background: var(--success-color); color: white;">
                <i class="fas fa-check"></i>
            </button>
            <button class="icon-btn" onclick="cancelVoiceRecording()" style="background: var(--error-color); color: white;">
                <i class="fas fa-times"></i>
            </button>
        </div>
    </div>
    
    <!-- Минимизированный звонок -->
    <div class="minimized-call" id="minimizedCall">
        <div class="call-info">
            <i class="fas fa-phone"></i> Активный звонок
        </div>
        <div class="call-controls">
            <button class="call-action-btn" onclick="maximizeCall()">
                <i class="fas fa-expand"></i>
            </button>
            <button class="call-action-btn end-call" onclick="endCall()">
                <i class="fas fa-phone-slash"></i>
            </button>
        </div>
    </div>
    
    <!-- Скрытые инпуты для загрузки файлов -->
    <input type="file" id="imageInput" class="file-input" accept="image/*" style="display: none;">
    <input type="file" id="fileInput" class="file-input" accept="*/*" style="display: none;">
    <input type="file" id="avatarUpload" accept="image/*" style="display: none;">
    
    <!-- Модальное окно настроек -->
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Настройки</div>
                <button class="close-modal" onclick="closeSettings()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="settings-section">
                    <div class="settings-title">Внешний вид</div>
                    <div class="setting-item">
                        <label class="setting-label">Тема</label>
                        <select class="setting-select" id="themeSelect">
                            <option value="light">Светлая</option>
                            <option value="dark">Темная</option>
                        </select>
                    </div>
                </div>
                
                <div class="settings-section">
                    <div class="settings-title">Аватарка</div>
                    
                    <!-- Загрузка пользовательского аватара -->
                    <div class="setting-item">
                        <label class="setting-label">Загрузить свою аватарку</label>
                        <button class="add-friends-btn" style="width: 100%;" onclick="document.getElementById('avatarUpload').click()">
                            <i class="fas fa-upload"></i> Выбрать изображение
                        </button>
                        <div style="font-size: 0.8em; color: var(--text-light); margin-top: 5px;">
                            Рекомендуемый размер: 200x200px, форматы: JPG, PNG, GIF
                        </div>
                    </div>
                    
                    <!-- Предпросмотр загруженного аватара -->
                    <div class="avatar-preview-container" style="text-align: center; margin: 15px 0; display: none;" id="avatarPreviewContainer">
                        <div style="font-weight: 600; margin-bottom: 10px;">Предпросмотр:</div>
                        <div class="avatar-preview" style="width: 100px; height: 100px; border-radius: 50%; overflow: hidden; margin: 0 auto; border: 3px solid var(--primary-color);">
                            <img id="avatarPreview" src="" alt="Preview" style="width: 100%; height: 100%; object-fit: cover;">
                        </div>
                        <div style="margin-top: 10px;">
                            <button class="add-friends-btn" onclick="saveCustomAvatar()" style="margin-right: 10px;">
                                <i class="fas fa-save"></i> Сохранить
                            </button>
                            <button class="clear-chat-btn" onclick="cancelAvatarUpload()">
                                <i class="fas fa-times"></i> Отмена
                            </button>
                        </div>
                    </div>
                    
                    <!-- Стандартные аватарки -->
                    <div style="margin-top: 20px;">
                        <div style="font-weight: 600; margin-bottom: 10px;">Стандартные аватарки:</div>
                        <div class="avatar-selection" id="avatarSelection">
                            <div class="avatar-option" data-avatar="default" onclick="selectDefaultAvatar('default')">
                                <div style="width: 100%; height: 100%; background: var(--primary-color); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">
                                    U
                                </div>
                            </div>
                            <div class="avatar-option" data-avatar="1" onclick="selectDefaultAvatar('1')">
                                <div style="width: 100%; height: 100%; background: #ff6b6b; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">
                                    A1
                                </div>
                            </div>
                            <div class="avatar-option" data-avatar="2" onclick="selectDefaultAvatar('2')">
                                <div style="width: 100%; height: 100%; background: #4ecdc4; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">
                                    A2
                                </div>
                            </div>
                            <div class="avatar-option" data-avatar="3" onclick="selectDefaultAvatar('3')">
                                <div style="width: 100%; height: 100%; background: #45b7d1; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">
                                    A3
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="settings-section">
                    <div class="settings-title">Уведомления</div>
                    <div class="setting-item">
                        <label class="setting-label">Звуковые уведомления</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="notificationsToggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
                
                <div class="settings-section">
                    <div class="settings-title">Устройства</div>
                    <div class="permission-guide">
                        <h4>⚠️ Важно: Разрешения для звонков</h4>
                        <p>Для работы звонков необходимо предоставить доступ к микрофону и камере:</p>
                        <ol class="permission-steps">
                            <li>Нажмите "Запросить разрешения" ниже</li>
                            <li>В появившемся окне браузера разрешите доступ к микрофону и камере</li>
                            <li>Если доступ заблокирован, нажмите на значок 🔒 в адресной строке и разрешите доступ</li>
                        </ol>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">Микрофон</label>
                        <select class="setting-select" id="microphoneSelect">
                            <option value="default">Устройство по умолчанию</option>
                        </select>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">Камера</label>
                        <select class="setting-select" id="cameraSelect">
                            <option value="default">Устройство по умолчанию</option>
                        </select>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">Наушники</label>
                        <select class="setting-select" id="audioOutputSelect">
                            <option value="default">Устройство по умолчанию</option>
                        </select>
                    </div>
                    <div class="setting-item">
                        <button class="add-friends-btn" style="width: 100%;" onclick="requestMediaPermissions()">
                            <i class="fas fa-microphone"></i> Запросить разрешения
                        </button>
                    </div>
                </div>
                
                <div class="settings-section">
                    <div class="settings-title">Управление друзьями</div>
                    <div class="friend-management">
                        <input type="text" class="friend-username-input" id="friendUsernameInput" placeholder="Введите username">
                        <button class="add-friend-submit" onclick="addFriendByUsername()">Добавить</button>
                    </div>
                </div>
                
                <div class="settings-section">
                    <div class="settings-title">Аккаунт</div>
                    <button class="add-friends-btn" style="width: 100%; margin-bottom: 10px;" onclick="switchTab('search'); closeSettings();">
                        <i class="fas fa-user-plus"></i> Найти друзей
                    </button>
                    <button class="call-btn" style="width: 100%; background: var(--error-color);" onclick="logout()">
                        <i class="fas fa-sign-out-alt"></i> Выйти из аккаунта
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Модальное окно заявок в друзья -->
    <div class="modal" id="friendRequestsModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Заявки в друзья</div>
                <button class="close-modal" onclick="closeFriendRequests()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="friend-requests-list" id="modalFriendRequestsList">
                    <!-- Friend requests will be populated by JavaScript -->
                </div>
            </div>
        </div>
    </div>
    
   <!-- Модальное окно активного звонка -->
<div class="call-modal" id="callModal">
    <div class="call-container">
        <div class="call-header">
            <h2 id="callUserInfo">Звонок пользователю</h2>
            <div id="callStatus" class="call-status">Соединение...</div>
        </div>
        
        <div class="video-section">
            <div class="video-main">
                <video id="remoteVideo" autoplay class="video-element remote-video"></video>
                <div class="video-overlay">
                    <div class="user-info">
                        <div class="user-avatar-large">
                            <div id="remoteUserAvatar">U</div>
                        </div>
                        <div class="user-name" id="remoteUserName">Пользователь</div>
                    </div>
                </div>
                <div class="speaking-indicator" id="remoteSpeakingIndicator">
                    <i class="fas fa-microphone"></i> Собеседник говорит
                </div>
            </div>
            
            <div class="video-pip">
                <video id="localVideo" autoplay muted class="video-element local-video"></video>
                <div class="speaking-indicator" id="localSpeakingIndicator">
                    <i class="fas fa-microphone"></i> Вы говорите
                </div>
            </div>
        </div>
        
        <div class="call-controls-section">
            <div class="volume-controls">
                <div class="volume-control">
                    <i class="fas fa-microphone"></i>
                    <input type="range" class="volume-slider" id="localVolume" min="0" max="1" step="0.1" value="1">
                    <span>Микрофон</span>
                </div>
                <div class="volume-control">
                    <i class="fas fa-volume-up"></i>
                    <input type="range" class="volume-slider" id="remoteVolume" min="0" max="1" step="0.1" value="1">
                    <span>Громкость</span>
                </div>
            </div>
            
            <div class="call-controls">
                <button class="call-action-btn mute-btn active" id="muteBtn" onclick="toggleMic()" title="Микрофон">
                    <i class="fas fa-microphone"></i>
                </button>
                <button class="call-action-btn video-btn active" id="videoBtn" onclick="toggleCamera()" title="Камера">
                    <i class="fas fa-video"></i>
                </button>
                <button class="call-action-btn screen-share-btn" id="screenShareBtn" onclick="toggleScreenShare()" title="Демонстрация экрана">
                    <i class="fas fa-desktop"></i>
                </button>
                <button class="call-action-btn minimize-btn" onclick="minimizeCall()" title="Свернуть">
                    <i class="fas fa-window-minimize"></i>
                </button>
                <button class="call-action-btn end-call" onclick="endCall()" title="Завершить звонок">
                    <i class="fas fa-phone-slash"></i>
                </button>
            </div>
        </div>
    </div>
</div>
    
    <!-- Модальное окно входящего звонка -->
    <div class="call-modal" id="incomingCallModal">
        <div class="call-content">
            <div class="call-user" id="incomingCallUserInfo">Входящий звонок</div>
            <div id="incomingCallStatus">Вам звонят...</div>
            <div class="call-controls">
                <button class="call-action-btn accept-call" onclick="acceptCall()">
                    <i class="fas fa-phone"></i>
                </button>
                <button class="call-action-btn reject-call" onclick="rejectCall()">
                    <i class="fas fa-phone-slash"></i>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Модальное окно предпросмотра изображений -->
    <div class="image-preview-modal" id="imagePreviewModal">
        <button class="close-preview" onclick="closeImagePreview()">&times;</button>
        <div class="image-preview-content">
            <img id="previewImage" src="" alt="Preview">
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Global variables
let socket;
let currentUser;
let selectedUser = null;
let peerConnection = null;
let localStream = null;
let currentCall = null;
let isIncomingCall = false;
let isCallActive = false;
let emojiPickerVisible = false;
let gifPickerVisible = false;
let authToken = null;
let isMicOn = true;
let isCameraOn = true;
let isScreenSharing = false;
let friendRequests = [];
let mediaPermissionsGranted = false;
let minimizedCall = false;
let audioContext = null;
let analyser = null;
let microphone = null;
let javascriptNode = null;
let isSpeaking = false;

// Voice recording variables
let mediaRecorder;
let audioChunks = [];
let recordingTimer;
let recordingStartTime;
let isRecording = false;
let currentAudio = null;

// Volume control
let localVolume = 1.0;
let remoteVolume = 1.0;

// Message management
let currentChatMessages = [];

let customAvatarFile = null;
// Common emojis
const emojis = ['😀', '😃', '😄', '😁', '😆', '😅', '😂', '🤣', '😊', '😇', '🙂', '🙃', '😉', '😌', '😍', '🥰', '😘', '😗', '😙', '😚', '😋', '😛', '😝', '😜', '🤪', '🤨', '🧐', '🤓', '😎', '🤩', '🥳', '😏', '😒', '😞', '😔', '😟', '😕', '🙁', '☹️', '😣', '😖', '😫', '😩', '🥺', '😢', '😭', '😤', '😠', '😡', '🤬', '🤯', '😳', '🥵', '🥶', '😱', '😨', '😰', '😥', '😓', '🤗', '🤔', '🤭', '🤫', '🤥', '😶', '😐', '😑', '😬', '🙄', '😯', '😦', '😧', '😮', '😲', '🥱', '😴', '🤤', '😪', '😵', '🤐', '🥴', '🤢', '🤮', '🤧', '😷', '🤒', '🤕', '🤑', '🤠', '😈', '👿', '👹', '👺', '🤡', '💩', '👻', '💀', '☠️', '👽', '👾', '🤖', '🎃', '😺', '😸', '😹', '😻', '😼', '😽', '🙀', '😿', '😾'];

// Initialize app
document.addEventListener('DOMContentLoaded', async () => {
    // Check authentication using sessionStorage
    await checkAuthentication();
    
    if (!currentUser) {
        console.log('No user found, redirecting to login');
        window.location.href = '/login';
        return;
    }
    
    console.log('User authenticated:', currentUser.username);
    
    // Initialize UI
    initializeUI();
    
    // Connect to Socket.io
    socket = io();
    socket.emit('user_online', currentUser);
    
    // Load users and messages
    await loadUsers();
    await loadFriendRequests();
    setupEmojiPicker();
    setupEventListeners();
    loadUserSettings();
    
    // Socket event listeners
    socket.on('private_message', handlePrivateMessage);
    socket.on('online_users', updateOnlineUsers);
    socket.on('user_status_changed', handleUserStatusChange);
    socket.on('incoming_call', handleIncomingCall);
    socket.on('call_accepted', handleCallAccepted);
    socket.on('call_rejected', handleCallRejected);
    socket.on('call_ended', handleCallEnded);
    socket.on('ice_candidate', handleIceCandidate);
    socket.on('friend_request_received', handleFriendRequestReceived);
    socket.on('friend_request_accepted', handleFriendRequestAccepted);
    socket.on('message_deleted', handleMessageDeleted);
    
    // Check if user has friends
    checkFriendsStatus();
    
    // Setup storage event listener for multi-tab sync
    window.addEventListener('storage', handleStorageChange);
});

// Authentication functions
async function checkAuthentication() {
    // Try to get token from sessionStorage
    authToken = sessionStorage.getItem('authToken');
    const savedUser = sessionStorage.getItem('currentUser');
    
    console.log('Auth check - Token:', authToken ? 'exists' : 'missing', 'User:', savedUser ? 'exists' : 'missing');
    
    if (authToken && savedUser) {
        try {
            // Validate token with server
            const response = await fetch('/api/validate', {
                headers: {
                    'Authorization': authToken
                }
            });
            
            if (response.ok) {
                const data = await response.json();
                currentUser = data.user;
                sessionStorage.setItem('currentUser', JSON.stringify(currentUser));
                console.log('Token validated successfully');
            } else {
                console.log('Token validation failed');
                // Token is invalid, clear storage
                clearAuthData();
            }
        } catch (error) {
            console.error('Auth validation error:', error);
            clearAuthData();
        }
    } else if (savedUser) {
        // Legacy support - user exists but no token
        console.log('Using legacy user data');
        currentUser = JSON.parse(savedUser);
        authToken = currentUser.id;
        sessionStorage.setItem('authToken', authToken);
    } else {
        console.log('No authentication data found');
        clearAuthData();
    }
}

function clearAuthData() {
    sessionStorage.removeItem('authToken');
    sessionStorage.removeItem('currentUser');
    currentUser = null;
    authToken = null;
}

function handleStorageChange(e) {
    if (e.key === 'authToken' && e.newValue === null) {
        // Auth token was cleared in another tab - logout
        console.log('Auth token cleared in another tab, logging out');
        logout();
    }
}

function initializeUI() {
    if (!currentUser) {
        console.log('No current user in initializeUI, redirecting to login');
        window.location.href = '/login';
        return;
    }
    
    document.getElementById('currentUserName').textContent = currentUser.username;
    
    // Apply saved theme
    if (currentUser.settings && currentUser.settings.theme) {
        document.body.setAttribute('data-theme', currentUser.settings.theme);
        document.getElementById('themeSelect').value = currentUser.settings.theme;
    }

    // Initialize avatar settings if not exists
    if (!currentUser.settings) {
        currentUser.settings = {};
    }
    if (!currentUser.settings.avatar) {
        currentUser.settings.avatar = 'default';
    }
    if (!currentUser.settings.avatarType) {
        currentUser.settings.avatarType = 'default';
    }
    
    // Update avatar display
    updateUserAvatar();
    
    console.log('UI initialized for user:', currentUser.username);
}

function setupEventListeners() {
    // Message input enter key
    document.getElementById('messageInput').addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });
    
    // File input change
    document.getElementById('imageInput').addEventListener('change', handleImageUpload);
    document.getElementById('fileInput').addEventListener('change', handleFileUpload);
    
    // Search input
    document.getElementById('searchInput').addEventListener('input', debounce(searchUsers, 300));
    
    // Click outside to close emoji picker
    document.addEventListener('click', (e) => {
        if (!e.target.closest('#emojiPicker') && !e.target.closest('.action-btn')) {
            hideEmojiPicker();
        }
        if (!e.target.closest('#gifPicker') && !e.target.closest('.action-btn')) {
            hideGifPicker();
        }
    });
    document.getElementById('avatarUpload').addEventListener('change', handleAvatarUpload);
    // Clear chat button
    document.getElementById('clearChatBtn').addEventListener('click', clearChat);
    
    // Volume controls
    document.getElementById('localVolume').addEventListener('input', updateLocalVolume);
    document.getElementById('remoteVolume').addEventListener('input', updateRemoteVolume);
    
    // Screen share button
    document.getElementById('screenShareBtn').addEventListener('click', toggleScreenShare);
}

function setupEmojiPicker() {
    const emojiGrid = document.getElementById('emojiGrid');
    emojis.forEach(emoji => {
        const emojiElement = document.createElement('div');
        emojiElement.className = 'emoji';
        emojiElement.textContent = emoji;
        emojiElement.addEventListener('click', () => {
            addEmojiToMessage(emoji);
        });
        emojiGrid.appendChild(emojiElement);
    });
}

function toggleEmojiPicker() {
    const picker = document.getElementById('emojiPicker');
    hideGifPicker();
    if (emojiPickerVisible) {
        picker.style.display = 'none';
    } else {
        picker.style.display = 'block';
    }
    emojiPickerVisible = !emojiPickerVisible;
}

function hideEmojiPicker() {
    document.getElementById('emojiPicker').style.display = 'none';
    emojiPickerVisible = false;
}

function toggleGifPicker() {
    const picker = document.getElementById('gifPicker');
    hideEmojiPicker();
    if (gifPickerVisible) {
        picker.style.display = 'none';
    } else {
        picker.style.display = 'block';
        searchGifs(); // Load initial GIFs
    }
    gifPickerVisible = !gifPickerVisible;
}

function hideGifPicker() {
    document.getElementById('gifPicker').style.display = 'none';
    gifPickerVisible = false;
}

// Improved GIF search with fallback
async function searchGifs() {
    const query = document.getElementById('gifSearch').value || 'hello';
    const gifGrid = document.getElementById('gifGrid');
    
    // Show loading
    gifGrid.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; padding: 20px; color: var(--text-light);">Загрузка GIF...</div>';
    
    try {
        // Using Giphy with demo key (limited usage)
        const apiKey = 'dc6zaTOxFJmzC'; // Giphy demo key
        const response = await fetch(`https://api.giphy.com/v1/gifs/search?q=${encodeURIComponent(query)}&api_key=${apiKey}&limit=12`);
        
        if (response.ok) {
            const data = await response.json();
            const gifs = data.data.map(gif => ({
                url: gif.images.original.url,
                preview: gif.images.preview_gif.url
            }));
            
            // Display GIFs
            gifGrid.innerHTML = '';
            if (gifs.length === 0) {
                gifGrid.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; padding: 20px; color: var(--text-light);">GIF не найдены</div>';
                return;
            }
            
            gifs.forEach(gif => {
                const gifElement = document.createElement('div');
                gifElement.className = 'gif-item';
                gifElement.innerHTML = `<img src="${gif.preview}" alt="GIF" onclick="sendGif('${gif.url}')">`;
                gifGrid.appendChild(gifElement);
            });
        } else {
            throw new Error('GIPHY API failed');
        }
    } catch (error) {
        console.error('Error searching GIFs:', error);
        // Fallback to static GIFs
        loadStaticGifs();
    }
}

function loadStaticGifs() {
    const gifGrid = document.getElementById('gifGrid');
    const staticGifs = [
        { url: 'https://media.giphy.com/media/3o7aCTPPm4OHfRLSH6/giphy.gif', preview: 'https://media.giphy.com/media/3o7aCTPPm4OHfRLSH6/giphy-preview.gif' },
        { url: 'https://media.giphy.com/media/l0HlRnAWXxn0MhKLK/giphy.gif', preview: 'https://media.giphy.com/media/l0HlRnAWXxn0MhKLK/giphy-preview.gif' },
        { url: 'https://media.giphy.com/media/3o72FfM5HJydzafgUE/giphy.gif', preview: 'https://media.giphy.com/media/3o72FfM5HJydzafgUE/giphy-preview.gif' },
        { url: 'https://media.giphy.com/media/26uf759LlDftqZNVm/giphy.gif', preview: 'https://media.giphy.com/media/26uf759LlDftqZNVm/giphy-preview.gif' }
    ];
    
    gifGrid.innerHTML = '';
    staticGifs.forEach(gif => {
        const gifElement = document.createElement('div');
        gifElement.className = 'gif-item';
        gifElement.innerHTML = `<img src="${gif.preview}" alt="GIF" onclick="sendGif('${gif.url}')">`;
        gifGrid.appendChild(gifElement);
    });
}

function sendGif(gifUrl) {
    if (!selectedUser) return;
    
    socket.emit('private_message', {
        to: selectedUser.id,
        message: gifUrl,
        from: currentUser.id,
        type: 'gif'
    });
    
    hideGifPicker();
}

function addEmojiToMessage(emoji) {
    const messageInput = document.getElementById('messageInput');
    messageInput.value += emoji;
    messageInput.focus();
    hideEmojiPicker();
}

async function loadUsers() {
    try {
        const response = await fetch('/api/users');
        const users = await response.json();
        displayUsers(users);
    } catch (error) {
        console.error('Error loading users:', error);
    }
}

function displayUsers(users) {
    const usersList = document.getElementById('usersList');
    usersList.innerHTML = '';
    
    const friends = users.filter(user => 
        user.id !== currentUser.id && currentUser.friends.includes(user.id)
    );
    
    // Display friends
    if (friends.length > 0) {
        const friendsHeader = document.createElement('div');
        friendsHeader.style.padding = '10px 15px';
        friendsHeader.style.fontWeight = '600';
        friendsHeader.style.color = 'var(--primary-color)';
        friendsHeader.textContent = `Друзья (${friends.length})`;
        usersList.appendChild(friendsHeader);
        
        friends.forEach(user => {
            usersList.appendChild(createUserElement(user, true));
        });
    } else {
        usersList.innerHTML = `
            <div style="text-align: center; padding: 40px 20px; color: var(--text-light);">
                <i class="fas fa-user-friends" style="font-size: 40px; margin-bottom: 15px; opacity: 0.5;"></i>
                <div>У вас пока нет друзей</div>
                <div style="font-size: 0.9em; margin-top: 10px;">Используйте вкладку "Поиск" чтобы найти друзей</div>
            </div>
        `;
    }
}

function createUserElement(user, isFriend) {
    const userElement = document.createElement('div');
    userElement.className = 'user-item';
    userElement.innerHTML = `
        <div class="user-avatar-small">
            ${user.username.charAt(0).toUpperCase()}
            <div class="online-status ${user.isOnline ? 'online' : 'offline'}"></div>
        </div>
        <div class="user-details-small">
            <div class="user-name-small">${user.username}</div>
            <div class="user-status-small">${user.isOnline ? 'online' : 'offline'}</div>
        </div>
        ${isFriend ? 
            `<button class="remove-friend-btn" onclick="event.stopPropagation(); removeFriend('${user.id}')">
                <i class="fas fa-user-minus"></i> Удалить
            </button>` : 
            ''
        }
    `;
    
    userElement.addEventListener('click', () => selectUser(user));
    return userElement;
}

function checkFriendsStatus() {
    const hasFriends = currentUser.friends && currentUser.friends.length > 0;
    
    if (hasFriends) {
        document.getElementById('noFriendsView').style.display = 'none';
        document.getElementById('chatView').style.display = 'flex';
    } else {
        document.getElementById('noFriendsView').style.display = 'flex';
        document.getElementById('chatView').style.display = 'none';
    }
}

async function selectUser(user) {
    selectedUser = user;
    
    // Update UI
    document.querySelectorAll('.user-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // Find and activate the clicked user item
    const userItems = document.querySelectorAll('.user-item');
    for (let item of userItems) {
        if (item.querySelector('.user-name-small')?.textContent === user.username) {
            item.classList.add('active');
            break;
        }
    }
    
    document.getElementById('chatWithUser').textContent = user.username;
    
    // Update chat user avatar
    const chatUserAvatarImg = document.getElementById('chatUserAvatarImg');
    const chatUserAvatarFallback = document.getElementById('chatUserAvatarFallback');
    
    chatUserAvatarFallback.textContent = user.username.charAt(0).toUpperCase();
    chatUserAvatarImg.style.display = 'none';
    chatUserAvatarFallback.style.display = 'block';
    
    document.getElementById('chatUserStatusText').textContent = user.isOnline ? 'online' : 'offline';
    document.getElementById('chatUserStatus').className = `online-status ${user.isOnline ? 'online' : 'offline'}`;
    document.getElementById('callButton').disabled = !user.isOnline;
     document.getElementById('messageInput').disabled = false;
    document.getElementById('sendButton').disabled = false;
    document.getElementById('clearChatBtn').style.display = 'block';
    
    // Show/hide non-friend banner
    const isFriend = currentUser.friends.includes(user.id);
    document.getElementById('nonFriendBanner').style.display = isFriend ? 'none' : 'block';
     setTimeout(() => {
        document.getElementById('messageInput').focus();
    }, 100);
    
    // Load chat history
    loadChatHistory(user.id);
}

async function loadChatHistory(friendId) {
    try {
        console.log('Loading chat history for:', friendId);
        const response = await fetch(`/api/messages/${currentUser.id}/${friendId}`);
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const messages = await response.json();
        console.log('Loaded messages:', messages);
        
        currentChatMessages = messages;
        
        const messagesContainer = document.getElementById('messages');
        messagesContainer.innerHTML = '';
        
        if (messages.length === 0) {
            messagesContainer.innerHTML = '<div style="text-align: center; color: var(--text-light); margin-top: 20px;">Начните общение с этим пользователем</div>';
            return;
        }
        
        messages.forEach(message => {
            displayMessage(message, message.from === currentUser.id);
        });
        
        // Scroll to bottom
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    } catch (error) {
        console.error('Error loading chat history:', error);
        showNotification('Ошибка загрузки сообщений', 'error');
    }
}
function sendMessage() {
    const messageInput = document.getElementById('messageInput');
    const message = messageInput.value.trim();
    
    if (!message || !selectedUser) return;
    
    // Check if message contains URLs for link preview
    const urlRegex = /(https?:\/\/[^\s]+)/g;
    const urls = message.match(urlRegex);
    
    // Send message via Socket.io
    socket.emit('private_message', {
        to: selectedUser.id,
        message: message,
        from: currentUser.id,
        type: 'text',
        urls: urls || []
    });
    
    // Clear input immediately for better UX
    messageInput.value = '';
    autoResize(messageInput);
    
    console.log('Message sent:', message);
}

function handlePrivateMessage(data) {
    if (selectedUser && (data.from === selectedUser.id || data.from === currentUser.id)) {
        displayMessage(data, data.from === currentUser.id);
        currentChatMessages.push(data);
        
        // Scroll to bottom
        const messagesContainer = document.getElementById('messages');
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
}
socket.on('private_message', (data) => {
    console.log('Received private message:', data);
    
    // If we're chatting with this user, display the message
    if (selectedUser && (data.from === selectedUser.id || data.to === selectedUser.id)) {
        displayMessage(data, data.from === currentUser.id);
        currentChatMessages.push(data);
        
        // Scroll to bottom
        const messagesContainer = document.getElementById('messages');
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
});
function displayMessage(message, isSent) {
    const messagesContainer = document.getElementById('messages');
    
    // Remove placeholder if exists
    const placeholder = messagesContainer.querySelector('div[style*="text-align: center"]');
    if (placeholder) {
        placeholder.remove();
    }

    // If messages container is empty, remove any placeholder text
    if (messagesContainer.children.length === 0 || 
        (messagesContainer.children.length === 1 && 
         messagesContainer.children[0].style.textAlign === 'center')) {
        messagesContainer.innerHTML = '';
    }

    // Check if we need to add a date separator
    const lastMessageElement = messagesContainer.lastElementChild;
    const lastMessage = lastMessageElement && lastMessageElement.dataset.timestamp ? 
        { timestamp: lastMessageElement.dataset.timestamp } : null;
    
    if (shouldShowDateSeparator(lastMessage, message)) {
        const dateSeparator = createDateSeparator(message.timestamp);
        messagesContainer.appendChild(dateSeparator);
    }
    
    const messageElement = document.createElement('div');
    messageElement.className = `message ${isSent ? 'sent' : 'received'}`;
    messageElement.dataset.messageId = message.id;
    messageElement.dataset.timestamp = message.timestamp;
    
    let content = '';
    if (message.type === 'image') {
        content = `<img src="${message.content}" alt="Image" class="message-image" onclick="previewImage('${message.content}')">`;
    } else if (message.type === 'gif') {
        content = `<img src="${message.content}" alt="GIF" class="message-gif" onclick="previewImage('${message.content}')">`;
    } else if (message.type === 'file') {
        const fileSize = message.fileSize ? formatFileSize(message.fileSize) : 'Неизвестный размер';
        content = `
            <div class="message-file">
                <div class="file-icon">
                    <i class="fas fa-file"></i>
                </div>
                <div class="file-info">
                    <div class="file-name">${message.fileName || 'Файл'}</div>
                    <div class="file-size">${fileSize}</div>
                </div>
                <button class="download-btn" onclick="downloadFile('${message.content}', '${message.fileName || 'file'}')">
                    <i class="fas fa-download"></i>
                </button>
            </div>
        `;
    } else if (message.type === 'voice') {
        content = `
            <div class="voice-message">
                <button class="voice-play-btn" onclick="playVoiceMessage('${message.content}', this)">
                    <i class="fas fa-play"></i>
                </button>
                <div class="voice-progress" onclick="seekVoiceMessage(event, '${message.content}')">
                    <div class="voice-progress-bar"></div>
                </div>
                <div class="voice-duration">--:--</div>
            </div>
        `;
    } else {
        content = `<div style="white-space: pre-wrap;">${formatMessageWithLinks(message.content)}</div>`;
        
        // Add link preview if URLs are present
        if (message.urls && message.urls.length > 0) {
            message.urls.forEach(url => {
                setTimeout(async () => {
                    const previewHTML = await createLinkPreview(url);
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = previewHTML;
                    messageElement.appendChild(tempDiv.firstChild);
                }, 100);
            });
        }
    }
    
    // Add delete button for user's own messages
    const deleteButton = isSent ? `
        <button class="delete-message-btn" onclick="deleteMessage('${message.id}')" title="Удалить сообщение">
            <i class="fas fa-trash"></i>
        </button>
    ` : '';
    
    messageElement.innerHTML = `
        ${content}
        <div class="message-time">${formatMessageTime(message.timestamp)}</div>
        ${deleteButton}
    `;
    
    messagesContainer.appendChild(messageElement);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

function formatMessageWithLinks(text) {
    const urlRegex = /(https?:\/\/[^\s]+)/g;
    return text.replace(urlRegex, '<a href="$1" target="_blank" style="color: var(--primary-color);">$1</a>');
}

async function createLinkPreview(url) {
    try {
        const response = await fetch(`/api/link-preview?url=${encodeURIComponent(url)}`);
        const previewData = await response.json();
        
        return `
            <div class="link-preview">
                ${previewData.image ? `
                    <img src="${previewData.image}" alt="Preview" class="link-preview-image">
                ` : ''}
                <div class="link-preview-content">
                    <div class="link-preview-title">${previewData.title}</div>
                    ${previewData.description ? `
                        <div class="link-preview-description">${previewData.description}</div>
                    ` : ''}
                    <div class="link-preview-url">${previewData.url}</div>
                </div>
            </div>
        `;
    } catch (error) {
        console.error('Error creating link preview:', error);
        return `
            <div class="link-preview">
                <div class="link-preview-content">
                    <div class="link-preview-title">Ссылка</div>
                    <div class="link-preview-url">${url}</div>
                </div>
            </div>
        `;
    }
}

// Avatar functions
function handleAvatarUpload(event) {
    const file = event.target.files[0];
    if (!file) {
        console.log('No file selected');
        return;
    }
    
    console.log('File selected:', file.name, file.type, file.size);
    
    // Validate file type
    if (!file.type.startsWith('image/')) {
        showNotification('Пожалуйста, выберите изображение (JPEG, PNG, GIF)', 'error');
        return;
    }
    
    // Validate file size (max 5MB)
    if (file.size > 5 * 1024 * 1024) {
        showNotification('Размер файла не должен превышать 5MB', 'error');
        return;
    }
    
    customAvatarFile = file;
    
    // Show preview
    const reader = new FileReader();
    reader.onload = function(e) {
        console.log('File loaded, showing preview');
        document.getElementById('avatarPreview').src = e.target.result;
        document.getElementById('avatarPreviewContainer').style.display = 'block';
    };
    reader.onerror = function(error) {
        console.error('Error reading file:', error);
        showNotification('Ошибка при чтении файла', 'error');
    };
    reader.readAsDataURL(file);
}

function cancelAvatarUpload() {
    customAvatarFile = null;
    document.getElementById('avatarPreviewContainer').style.display = 'none';
    document.getElementById('avatarUpload').value = '';
}

async function saveCustomAvatar() {
    if (!customAvatarFile) {
        showNotification('Сначала выберите изображение', 'error');
        return;
    }
    
    try {
        // Convert to base64
        const reader = new FileReader();
        reader.onload = async function(e) {
            const base64Data = e.target.result;
            
            // Send to server
            const response = await fetch('/api/upload-avatar', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': authToken
                },
                body: JSON.stringify({
                    imageData: base64Data,
                    fileName: customAvatarFile.name
                })
            });
            
            if (response.ok) {
                const data = await response.json();
                
                // Update user settings
                currentUser.settings.avatar = data.avatarUrl;
                currentUser.settings.avatarType = 'custom';
                
                // Save settings
                await saveUserSettings();
                
                // Update UI
                updateUserAvatar();
                
                showNotification('Аватарка сохранена!', 'success');
                cancelAvatarUpload();
            } else {
                const errorData = await response.json();
                showNotification(errorData.error || 'Ошибка загрузки аватарки', 'error');
            }
        };
        reader.readAsDataURL(customAvatarFile);
        
    } catch (error) {
        console.error('Error uploading avatar:', error);
        showNotification('Ошибка загрузки аватарки', 'error');
    }
}

function selectDefaultAvatar(avatarId) {
    currentUser.settings.avatar = avatarId;
    currentUser.settings.avatarType = 'default';
    
    // Update UI
    document.querySelectorAll('.avatar-option').forEach(option => {
        option.classList.remove('selected');
    });
    event.target.closest('.avatar-option').classList.add('selected');
    
    // Update avatars
    updateUserAvatar();
    
    // Save settings
    saveUserSettings();
    
    showNotification('Аватарка изменена!', 'success');
}

function updateUserAvatar() {
    const userAvatar = document.getElementById('userAvatar');
    const userAvatarImg = document.getElementById('userAvatarImg');
    const userAvatarFallback = document.getElementById('userAvatarFallback');
    
    if (currentUser.settings.avatarType === 'custom' && currentUser.settings.avatar) {
        userAvatarImg.src = currentUser.settings.avatar;
        userAvatarImg.style.display = 'block';
        userAvatarFallback.style.display = 'none';
    } else {
        userAvatarImg.style.display = 'none';
        userAvatarFallback.style.display = 'block';
        userAvatarFallback.textContent = currentUser.username.charAt(0).toUpperCase();
    }
}

function updateCallAvatars() {
    const localAvatarImg = document.getElementById('localAvatarImg');
    const localAvatarFallback = document.getElementById('localAvatarFallback');
    
    if (currentUser.settings.avatarType === 'custom' && currentUser.settings.avatar) {
        localAvatarImg.src = currentUser.settings.avatar;
        localAvatarImg.style.display = 'block';
        localAvatarFallback.style.display = 'none';
    } else if (currentUser.settings.avatar && currentUser.settings.avatar !== 'default') {
        localAvatarImg.src = `/avatars/avatar${currentUser.settings.avatar}.png`;
        localAvatarImg.style.display = 'block';
        localAvatarFallback.style.display = 'none';
    } else {
        localAvatarImg.style.display = 'none';
        localAvatarFallback.style.display = 'block';
        localAvatarFallback.textContent = currentUser.username.charAt(0).toUpperCase();
    }
}

function formatFileSize(bytes) {
    if (!bytes) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

function downloadFile(dataUrl, fileName) {
    const link = document.createElement('a');
    link.href = dataUrl;
    link.download = fileName;
    link.click();
}

// Voice message functions
async function startVoiceRecording() {
    if (!selectedUser) {
        showNotification('Выберите пользователя для отправки голосового сообщения', 'warning');
        return;
    }
    
    try {
        // Request microphone permission
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        mediaRecorder = new MediaRecorder(stream);
        audioChunks = [];
        
        mediaRecorder.ondataavailable = (event) => {
            audioChunks.push(event.data);
        };
        
        mediaRecorder.onstop = async () => {
            const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
            const audioUrl = URL.createObjectURL(audioBlob);
            
            // Convert to base64 for sending
            const reader = new FileReader();
            reader.onload = async function() {
                const audioData = reader.result;
                
                try {
                    const response = await fetch('/api/upload-voice', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': authToken
                        },
                        body: JSON.stringify({
                            audioData: audioData,
                            fileName: `voice_${Date.now()}.wav`,
                            toUserId: selectedUser.id,
                            fromUserId: currentUser.id
                        })
                    });
                    
                    if (response.ok) {
                        showNotification('Голосовое сообщение отправлено', 'success');
                    } else {
                        throw new Error('Failed to upload voice message');
                    }
                } catch (error) {
                    console.error('Error sending voice message:', error);
                    showNotification('Ошибка отправки голосового сообщения', 'error');
                }
            };
            reader.readAsDataURL(audioBlob);
            
            // Stop all tracks
            stream.getTracks().forEach(track => track.stop());
        };
        
        // Start recording
        mediaRecorder.start();
        isRecording = true;
        recordingStartTime = Date.now();
        
        // Show recorder UI
        document.getElementById('voiceRecorder').style.display = 'flex';
        updateRecordingTimer();
        
    } catch (error) {
        console.error('Error starting voice recording:', error);
        showNotification('Не удалось получить доступ к микрофону. Проверьте разрешения браузера.', 'error');
    }
}

function updateRecordingTimer() {
    if (!isRecording) return;
    
    const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
    const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
    const seconds = (elapsed % 60).toString().padStart(2, '0');
    
    document.getElementById('recordingTimer').textContent = `${minutes}:${seconds}`;
    
    recordingTimer = setTimeout(updateRecordingTimer, 1000);
}

function sendVoiceMessage() {
    if (mediaRecorder && isRecording) {
        mediaRecorder.stop();
        stopRecording();
    }
}

function cancelVoiceRecording() {
    if (mediaRecorder && isRecording) {
        mediaRecorder.stop();
        stopRecording();
        showNotification('Запись отменена', 'info');
    }
}

function stopRecording() {
    isRecording = false;
    clearTimeout(recordingTimer);
    document.getElementById('voiceRecorder').style.display = 'none';
    
    // Stop all media tracks
    if (mediaRecorder && mediaRecorder.stream) {
        mediaRecorder.stream.getTracks().forEach(track => track.stop());
    }
}

// Voice message playback
function playVoiceMessage(audioUrl, buttonElement) {
    if (currentAudio) {
        currentAudio.pause();
        currentAudio = null;
    }
    
    currentAudio = new Audio(audioUrl);
    const progressBar = buttonElement.parentElement.querySelector('.voice-progress-bar');
    const durationElement = buttonElement.parentElement.querySelector('.voice-duration');
    const playButton = buttonElement;
    
    currentAudio.addEventListener('loadedmetadata', () => {
        durationElement.textContent = formatTime(currentAudio.duration);
    });
    
    currentAudio.addEventListener('timeupdate', () => {
        const progress = (currentAudio.currentTime / currentAudio.duration) * 100;
        progressBar.style.width = `${progress}%`;
        
        if (currentAudio.currentTime === currentAudio.duration) {
            playButton.innerHTML = '<i class="fas fa-play"></i>';
        }
    });
    
    if (currentAudio.paused) {
        currentAudio.play();
        playButton.innerHTML = '<i class="fas fa-pause"></i>';
    } else {
        currentAudio.pause();
        playButton.innerHTML = '<i class="fas fa-play"></i>';
    }
}

function seekVoiceMessage(event, audioUrl) {
    if (!currentAudio || currentAudio.src !== audioUrl) return;
    
    const progressBar = event.currentTarget;
    const clickX = event.offsetX;
    const width = progressBar.offsetWidth;
    const seekTime = (clickX / width) * currentAudio.duration;
    
    currentAudio.currentTime = seekTime;
}

function formatTime(seconds) {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
}
// В функции setupEventListeners добавьте:
function setupEventListeners() {
    // Message input events
    const messageInput = document.getElementById('messageInput');
    
    // Enter key to send message
    messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });
    
    // Auto-resize
    messageInput.addEventListener('input', function() {
        autoResize(this);
    });
    
    // Click on messages area to focus input
    document.getElementById('messages').addEventListener('click', () => {
        if (selectedUser) {
            messageInput.focus();
        }
    });
    
    // Click on chat area to focus input
    document.getElementById('chatView').addEventListener('click', (e) => {
        if (selectedUser && !e.target.closest('.message-actions') && !e.target.closest('.emoji-picker') && !e.target.closest('.gif-picker')) {
            messageInput.focus();
        }
    });
    
    // File input change
    document.getElementById('imageInput').addEventListener('change', handleImageUpload);
    document.getElementById('fileInput').addEventListener('change', handleFileUpload);
    
    // Search input
    document.getElementById('searchInput').addEventListener('input', debounce(searchUsers, 300));
    
    // Clear chat button
    document.getElementById('clearChatBtn').addEventListener('click', clearChat);
    
    // Volume controls
    document.getElementById('localVolume').addEventListener('input', updateLocalVolume);
    document.getElementById('remoteVolume').addEventListener('input', updateRemoteVolume);
    
    // Click outside to close emoji picker
    document.addEventListener('click', (e) => {
        if (!e.target.closest('#emojiPicker') && !e.target.closest('.action-btn')) {
            hideEmojiPicker();
        }
        if (!e.target.closest('#gifPicker') && !e.target.closest('.action-btn')) {
            hideGifPicker();
        }
    });
}

// Улучшенная функция выбора пользователя
function selectUser(user) {
    console.log('Selecting user:', user.username);
    
    selectedUser = user;
    
    // Update UI
    document.querySelectorAll('.user-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // Find and activate the clicked user item
    const userItems = document.querySelectorAll('.user-item');
    for (let item of userItems) {
        if (item.querySelector('.user-name-small')?.textContent === user.username) {
            item.classList.add('active');
            break;
        }
    }
    
    document.getElementById('chatWithUser').textContent = user.username;
    
    // Update chat user avatar
    const chatUserAvatarFallback = document.getElementById('chatUserAvatarFallback');
    chatUserAvatarFallback.textContent = user.username.charAt(0).toUpperCase();
    
    document.getElementById('chatUserStatusText').textContent = user.isOnline ? 'online' : 'offline';
    document.getElementById('chatUserStatus').className = `online-status ${user.isOnline ? 'online' : 'offline'}`;
    document.getElementById('callButton').disabled = !user.isOnline;
    
    // Enable input and focus
    const messageInput = document.getElementById('messageInput');
    const sendButton = document.getElementById('sendButton');
    
    messageInput.disabled = false;
    messageInput.placeholder = `Введите сообщение для ${user.username}...`;
    sendButton.disabled = false;
    
    document.getElementById('clearChatBtn').style.display = 'block';
    
    // Show/hide non-friend banner
    const isFriend = currentUser.friends && currentUser.friends.includes(user.id);
    document.getElementById('nonFriendBanner').style.display = isFriend ? 'none' : 'block';
    
    // Show chat view and hide no friends view
    document.getElementById('noFriendsView').style.display = 'none';
    document.getElementById('chatView').style.display = 'flex';
    
    // Load chat history
    loadChatHistory(user.id);
    
    // Focus on input after a short delay to ensure DOM is updated
    setTimeout(() => {
        messageInput.focus();
        console.log('Input should be focused now');
    }, 100);
}

// Улучшенная функция отправки сообщений
function sendMessage() {
    const messageInput = document.getElementById('messageInput');
    const message = messageInput.value.trim();
    
    if (!message || !selectedUser) {
        console.log('Cannot send: no message or no selected user');
        return;
    }
    
    console.log('Sending message to:', selectedUser.username, 'Content:', message);
    
    // Check if message contains URLs for link preview
    const urlRegex = /(https?:\/\/[^\s]+)/g;
    const urls = message.match(urlRegex);
    
    // Send message via Socket.io
    socket.emit('private_message', {
        to: selectedUser.id,
        message: message,
        from: currentUser.id,
        type: 'text',
        urls: urls || []
    });
    
    // Clear input immediately
    messageInput.value = '';
    autoResize(messageInput);
    
    // Keep focus on input
    messageInput.focus();
}

// Улучшенная функция авто-размера
function autoResize(textarea) {
    textarea.style.height = 'auto';
    textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
}

// Улучшенная функция загрузки истории чата
async function loadChatHistory(friendId) {
    try {
        console.log('Loading chat history for user:', friendId);
        const response = await fetch(`/api/messages/${currentUser.id}/${friendId}`);
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const messages = await response.json();
        console.log('Loaded messages:', messages.length);
        
        currentChatMessages = messages;
        
        const messagesContainer = document.getElementById('messages');
        messagesContainer.innerHTML = '';
        
        if (messages.length === 0) {
            messagesContainer.innerHTML = '<div style="text-align: center; color: var(--text-light); margin-top: 20px; padding: 20px;">Начните общение с этим пользователем</div>';
            return;
        }
        
        let previousMessage = null;
        messages.forEach(message => {
            // Check if we need to add a date separator
            if (shouldShowDateSeparator(previousMessage, message)) {
                const dateSeparator = createDateSeparator(message.timestamp);
                messagesContainer.appendChild(dateSeparator);
            }
            
            displayMessage(message, message.from === currentUser.id);
            previousMessage = message;
        });
        
        // Scroll to bottom
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        
    } catch (error) {
        console.error('Error loading chat history:', error);
        showNotification('Ошибка загрузки сообщений', 'error');
    }
}

// Улучшенная функция отображения сообщений
function displayMessage(message, isSent) {
    const messagesContainer = document.getElementById('messages');
    
    // Remove placeholder if exists
    const placeholder = messagesContainer.querySelector('div[style*="text-align: center"]');
    if (placeholder) {
        placeholder.remove();
    }
    
    // If messages container is empty, remove any placeholder text
    if (messagesContainer.children.length === 0 || 
        (messagesContainer.children.length === 1 && 
         messagesContainer.children[0].style.textAlign === 'center')) {
        messagesContainer.innerHTML = '';
    }
    
    const messageElement = document.createElement('div');
    messageElement.className = `message ${isSent ? 'sent' : 'received'}`;
    messageElement.dataset.messageId = message.id;
    
    let content = '';
    if (message.type === 'image') {
        content = `<img src="${message.content}" alt="Image" class="message-image" onclick="previewImage('${message.content}')">`;
    } else if (message.type === 'gif') {
        content = `<img src="${message.content}" alt="GIF" class="message-gif" onclick="previewImage('${message.content}')">`;
    } else if (message.type === 'file') {
        const fileSize = message.fileSize ? formatFileSize(message.fileSize) : 'Неизвестный размер';
        content = `
            <div class="message-file">
                <div class="file-icon">
                    <i class="fas fa-file"></i>
                </div>
                <div class="file-info">
                    <div class="file-name">${message.fileName || 'Файл'}</div>
                    <div class="file-size">${fileSize}</div>
                </div>
                <button class="download-btn" onclick="downloadFile('${message.content}', '${message.fileName || 'file'}')">
                    <i class="fas fa-download"></i>
                </button>
            </div>
        `;
    } else if (message.type === 'voice') {
        content = `
            <div class="voice-message">
                <button class="voice-play-btn" onclick="playVoiceMessage('${message.content}', this)">
                    <i class="fas fa-play"></i>
                </button>
                <div class="voice-progress" onclick="seekVoiceMessage(event, '${message.content}')">
                    <div class="voice-progress-bar"></div>
                </div>
                <div class="voice-duration">--:--</div>
            </div>
        `;
    } else {
        content = `<div style="white-space: pre-wrap;">${formatMessageWithLinks(message.content)}</div>`;
        
        // Add link preview if URLs are present
        if (message.urls && message.urls.length > 0) {
            message.urls.forEach(url => {
                setTimeout(async () => {
                    const previewHTML = await createLinkPreview(url);
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = previewHTML;
                    messageElement.appendChild(tempDiv.firstChild);
                }, 100);
            });
        }
    }
    
    // Add delete button for user's own messages
    const deleteButton = isSent ? `
        <button class="delete-message-btn" onclick="deleteMessage('${message.id}')" title="Удалить сообщение">
            <i class="fas fa-trash"></i>
        </button>
    ` : '';
    
    messageElement.innerHTML = `
        ${content}
        <div class="message-time">${formatMessageTime(message.timestamp)}</div>
        ${deleteButton}
    `;
    
    messagesContainer.appendChild(messageElement);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

// Вспомогательная функция для форматирования времени
function formatMessageTime(timestamp) {
    const date = new Date(timestamp);
    const now = new Date();
    const diffInHours = (now - date) / (1000 * 60 * 60);
    
    // Если сообщение отправлено сегодня, показываем только время
    if (date.toDateString() === now.toDateString()) {
        return date.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
    }
    // Если сообщение отправлено вчера, показываем "вчера" и время
    else if (diffInHours < 48) {
        return `вчера ${date.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' })}`;
    }
    // Если сообщение отправлено на этой неделе, показываем день недели и время
    else if (diffInHours < 168) {
        const days = ['вс', 'пн', 'вт', 'ср', 'чт', 'пт', 'сб'];
        return `${days[date.getDay()]} ${date.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' })}`;
    }
    // Иначе показываем полную дату и время
    else {
        return date.toLocaleDateString('ru-RU', { day: 'numeric', month: 'short' }) + ' ' + 
               date.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
    }
}

// Улучшенная функция проверки аутентификации
async function checkAuthentication() {
    // Try to get token from sessionStorage
    authToken = sessionStorage.getItem('authToken');
    const savedUser = sessionStorage.getItem('currentUser');
    
    console.log('Auth check - Token:', authToken ? 'exists' : 'missing', 'User:', savedUser ? 'exists' : 'missing');
    
    if (authToken && savedUser) {
        try {
            // Validate token with server
            const response = await fetch('/api/validate', {
                headers: {
                    'Authorization': authToken
                }
            });
            
            if (response.ok) {
                const data = await response.json();
                currentUser = data.user;
                sessionStorage.setItem('currentUser', JSON.stringify(currentUser));
                console.log('Token validated successfully for user:', currentUser.username);
                return true;
            } else {
                console.log('Token validation failed');
                clearAuthData();
                return false;
            }
        } catch (error) {
            console.error('Auth validation error:', error);
            clearAuthData();
            return false;
        }
    } else if (savedUser) {
        // Legacy support - user exists but no token
        console.log('Using legacy user data');
        currentUser = JSON.parse(savedUser);
        authToken = currentUser.id;
        sessionStorage.setItem('authToken', authToken);
        return true;
    } else {
        console.log('No authentication data found');
        clearAuthData();
        return false;
    }
}

// Улучшенная инициализация
document.addEventListener('DOMContentLoaded', async () => {
    console.log('DOM loaded, initializing app...');
    
    // Check authentication
    const isAuthenticated = await checkAuthentication();
    
    if (!isAuthenticated || !currentUser) {
        console.log('No user found, redirecting to login');
        window.location.href = '/login';
        return;
    }
    
    console.log('User authenticated:', currentUser.username);
    
    // Initialize UI
    initializeUI();
    
    // Connect to Socket.io
    socket = io();
    socket.emit('user_online', currentUser);
    
    // Load users and messages
    await loadUsers();
    await loadFriendRequests();
    setupEmojiPicker();
    setupEventListeners();
    loadUserSettings();
    
    // Socket event listeners
    socket.on('private_message', handlePrivateMessage);
    socket.on('online_users', updateOnlineUsers);
    socket.on('user_status_changed', handleUserStatusChange);
    socket.on('incoming_call', handleIncomingCall);
    socket.on('call_accepted', handleCallAccepted);
    socket.on('call_rejected', handleCallRejected);
    socket.on('call_ended', handleCallEnded);
    socket.on('ice_candidate', handleIceCandidate);
    socket.on('friend_request_received', handleFriendRequestReceived);
    socket.on('friend_request_accepted', handleFriendRequestAccepted);
    socket.on('message_deleted', handleMessageDeleted);
    
    // Check if user has friends
    checkFriendsStatus();
    
    // Setup storage event listener for multi-tab sync
    window.addEventListener('storage', handleStorageChange);
    
    console.log('App initialized successfully');
});
// Friend management functions
async function addFriendByUsername() {
    const usernameInput = document.getElementById('friendUsernameInput');
    const username = usernameInput.value.trim();
    
    if (!username) {
        showNotification('Введите username пользователя', 'error');
        return;
    }
    
    if (username === currentUser.username) {
        showNotification('Нельзя добавить себя в друзья', 'error');
        return;
    }
    
    try {
        const response = await fetch('/api/friend-requests', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': authToken
            },
            body: JSON.stringify({ fromUserId: currentUser.id, toUsername: username })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            showNotification('Заявка в друзья отправлена!', 'success');
            usernameInput.value = '';
            closeSettings();
        } else {
            showNotification(data.error, 'error');
        }
    } catch (error) {
        console.error('Error sending friend request:', error);
        showNotification('Ошибка при отправке заявки', 'error');
    }
}

function sendFriendRequest() {
    if (!selectedUser) return;
    
    fetch('/api/friend-requests', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': authToken
        },
        body: JSON.stringify({ fromUserId: currentUser.id, toUsername: selectedUser.username })
    })
    .then(response => response.json())
    .then(data => {
        if (data.message) {
            showNotification('Заявка в друзья отправлена!', 'success');
        } else {
            showNotification(data.error, 'error');
        }
    })
    .catch(error => {
        console.error('Error sending friend request:', error);
        showNotification('Ошибка при отправке заявки', 'error');
    });
}

async function removeFriend(friendId) {
    if (!confirm('Удалить пользователя из друзей?')) {
        return;
    }
    
    try {
        const response = await fetch(`/api/users/${currentUser.id}/friends/${friendId}`, {
            method: 'DELETE',
            headers: {
                'Authorization': authToken
            }
        });
        
        if (response.ok) {
            showNotification('Пользователь удален из друзей', 'success');
            
            // Update current user data
            currentUser.friends = currentUser.friends.filter(id => id !== friendId);
            sessionStorage.setItem('currentUser', JSON.stringify(currentUser));
            
            // Reload users and update UI
            await loadUsers();
            checkFriendsStatus();
            
            // If the removed friend was selected, clear chat
            if (selectedUser && selectedUser.id === friendId) {
                selectedUser = null;
                document.getElementById('chatWithUser').textContent = 'Выберите пользователя для чата';
                document.getElementById('messages').innerHTML = '<div style="text-align: center; color: var(--text-light); margin-top: 20px;">Начните общение с этим пользователем</div>';
                document.getElementById('callButton').disabled = true;
                document.getElementById('messageInput').disabled = true;
                document.getElementById('sendButton').disabled = true;
                document.getElementById('nonFriendBanner').style.display = 'none';
                document.getElementById('clearChatBtn').style.display = 'none';
            }
        } else {
            const data = await response.json();
            showNotification(data.error, 'error');
        }
    } catch (error) {
        console.error('Error removing friend:', error);
        showNotification('Ошибка при удалении друга', 'error');
    }
}

async function searchUsers() {
    const searchInput = document.getElementById('searchInput');
    const query = searchInput.value.trim();
    
    console.log('Searching for:', query, 'Current user:', currentUser.id);
    
    if (!query || query.length < 1) {
        const searchResults = document.getElementById('searchResults');
        if (searchResults) {
            searchResults.innerHTML = '';
            searchResults.style.display = 'none';
        }
        return;
    }
    
    try {
        // Показываем индикатор загрузки
        const searchResults = document.getElementById('searchResults');
        searchResults.innerHTML = '<div style="padding: 15px; text-align: center; color: var(--text-light); font-size: 0.9em;">Поиск...</div>';
        searchResults.style.display = 'block';
        
        const response = await fetch(`/api/users/search/${encodeURIComponent(query)}?currentUserId=${currentUser.id}`);
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const users = await response.json();
        console.log('Search results received:', users.length, 'users');
        
        searchResults.innerHTML = '';
        
        if (users.length === 0) {
            searchResults.innerHTML = '<div style="padding: 15px; text-align: center; color: var(--text-light); font-size: 0.9em;">Пользователи не найдены</div>';
            return;
        }
        
        users.forEach(user => {
            const userElement = document.createElement('div');
            userElement.className = 'user-item';
            
            // Компактная верстка
            if (user.isFriend) {
                userElement.innerHTML = `
                    <div class="user-avatar-small">
                        ${user.username.charAt(0).toUpperCase()}
                        <div class="online-status ${user.isOnline ? 'online' : 'offline'}"></div>
                    </div>
                    <div class="user-details-small">
                        <div class="user-name-small">${user.username}</div>
                        <div class="user-status-small">${user.isOnline ? 'online' : 'offline'}</div>
                    </div>
                    <div class="friend-status">
                        <i class="fas fa-check"></i> Друг
                    </div>
                `;
            } else {
                userElement.innerHTML = `
                    <div class="user-avatar-small">
                        ${user.username.charAt(0).toUpperCase()}
                        <div class="online-status ${user.isOnline ? 'online' : 'offline'}"></div>
                    </div>
                    <div class="user-details-small">
                        <div class="user-name-small">${user.username}</div>
                        <div class="user-status-small">${user.isOnline ? 'online' : 'offline'}</div>
                    </div>
                    <button class="add-friend-btn" onclick="event.stopPropagation(); addSearchedUser('${user.username}')">
                        <i class="fas fa-user-plus"></i> Добавить
                    </button>
                `;
            }
            
            userElement.addEventListener('click', (e) => {
                if (!e.target.closest('.add-friend-btn') && !e.target.closest('.friend-status')) {
                    selectUser(user);
                    // Скрываем результаты поиска после выбора
                    searchResults.style.display = 'none';
                    searchInput.value = '';
                    // Переключаемся на вкладку друзей
                    switchTab('friends');
                }
            });
            
            searchResults.appendChild(userElement);
        });
        
    } catch (error) {
        console.error('Error searching users:', error);
        const searchResults = document.getElementById('searchResults');
        if (searchResults) {
            searchResults.innerHTML = '<div style="padding: 15px; text-align: center; color: var(--error-color); font-size: 0.9em;">Ошибка поиска</div>';
        }
    }
}


async function addSearchedUser(username) {
    try {
        console.log('Sending friend request to:', username);
        const response = await fetch('/api/friend-requests', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': authToken
            },
            body: JSON.stringify({ 
                fromUserId: currentUser.id, 
                toUsername: username 
            })
        });
        
        const data = await response.json();
        console.log('Friend request response:', data);
        
        if (response.ok) {
            showNotification(`Заявка в друзья отправлена пользователю ${username}!`, 'success');
    
    // Обновляем статус в результатах поиска
    updateSearchResultStatus(username, 'pending');
            // Обновляем UI поиска
            const searchResults = document.getElementById('searchResults');
            if (searchResults) {
                // Находим элемент пользователя и обновляем его
                const userItems = searchResults.querySelectorAll('.user-item');
                userItems.forEach(item => {
                    const userName = item.querySelector('.user-name-small').textContent;
                    if (userName === username) {
                        // Заменяем кнопку на статус "Заявка отправлена"
                        const addButton = item.querySelector('.add-friend-btn');
                        if (addButton) {
                            addButton.outerHTML = '<div class="friend-status" style="color: var(--warning-color);"><i class="fas fa-clock"></i> Заявка отправлена</div>';
                        }
                    }
                });
            }
            
        } else {
            showNotification(data.error || 'Ошибка при отправке заявки', 'error');
        }
    } catch (error) {
        console.error('Error adding friend:', error);
        showNotification('Ошибка при отправке заявки', 'error');
    }
}

// Friend requests system
async function loadFriendRequests() {
    try {
        const response = await fetch(`/api/friend-requests/${currentUser.id}`);
        friendRequests = await response.json();
        updateFriendRequestsUI();
    } catch (error) {
        console.error('Error loading friend requests:', error);
    }
}

function updateFriendRequestsUI() {
    const pendingRequests = friendRequests.filter(req => req.status === 'pending');
    
    // Update badge counts
    document.getElementById('friendRequestsBadge').textContent = pendingRequests.length;
    document.getElementById('friendRequestsBadge').style.display = pendingRequests.length > 0 ? 'block' : 'none';
    
    document.getElementById('requestsTabBadge').textContent = pendingRequests.length;
    document.getElementById('requestsTabBadge').style.display = pendingRequests.length > 0 ? 'block' : 'none';
    
    // Update requests list
    const requestsList = document.getElementById('friendRequestsList');
    const modalRequestsList = document.getElementById('modalFriendRequestsList');
    
    if (pendingRequests.length === 0) {
        requestsList.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-light);">Нет новых заявок в друзья</div>';
        modalRequestsList.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-light);">Нет новых заявок в друзья</div>';
        return;
    }
    
    requestsList.innerHTML = '';
    modalRequestsList.innerHTML = '';
    
    pendingRequests.forEach(request => {
        const requestElement = document.createElement('div');
        requestElement.className = 'friend-request-item';
        requestElement.innerHTML = `
            <div>
                <div style="font-weight: 600;">${request.fromUsername}</div>
                <div style="font-size: 0.8em; color: var(--text-light);">${new Date(request.createdAt).toLocaleString()}</div>
            </div>
            <div class="friend-request-actions">
                <button class="accept-request" onclick="acceptFriendRequest('${request.id}')">
                    <i class="fas fa-check"></i>
                </button>
                <button class="decline-request" onclick="declineFriendRequest('${request.id}')">
                    <i class="fas fa-times"></i>
                </button>
            </div>
        `;
        
        requestsList.appendChild(requestElement.cloneNode(true));
        modalRequestsList.appendChild(requestElement);
    });
}

function acceptFriendRequest(requestId) {
    fetch(`/api/friend-requests/${requestId}/accept`, {
        method: 'POST',
        headers: {
            'Authorization': authToken
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.message) {
            showNotification('Заявка в друзья принята!', 'success');
            loadFriendRequests();
            loadUsers();
        } else {
            showNotification(data.error, 'error');
        }
    })
    .catch(error => {
        console.error('Error accepting friend request:', error);
        showNotification('Ошибка при принятии заявки', 'error');
    });
}

function declineFriendRequest(requestId) {
    fetch(`/api/friend-requests/${requestId}/decline`, {
        method: 'POST',
        headers: {
            'Authorization': authToken
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.message) {
            showNotification('Заявка в друзья отклонена', 'info');
            loadFriendRequests();
        } else {
            showNotification(data.error, 'error');
        }
    })
    .catch(error => {
        console.error('Error declining friend request:', error);
        showNotification('Ошибка при отклонении заявки', 'error');
    });
}

function handleFriendRequestReceived(data) {
    showNotification(`Пользователь ${data.fromUsername} отправил вам заявку в друзья`, 'info');
    loadFriendRequests();
}

function handleFriendRequestAccepted(data) {
    showNotification(`Пользователь ${data.friend.username} принял вашу заявку в друзья!`, 'success');
    currentUser.friends.push(data.friend.id);
    sessionStorage.setItem('currentUser', JSON.stringify(currentUser));
    loadUsers();
    checkFriendsStatus();
}

function openFriendRequests() {
    document.getElementById('friendRequestsModal').style.display = 'flex';
}

function closeFriendRequests() {
    document.getElementById('friendRequestsModal').style.display = 'none';
}

function switchTab(tab) {
    console.log('Switching to tab:', tab);
    
    // Скрываем все контейнеры
    document.getElementById('searchContainer').style.display = 'none';
    document.getElementById('usersList').style.display = 'none';
    document.getElementById('friendRequestsContainer').style.display = 'none';
    
    // Скрываем результаты поиска
    const searchResults = document.getElementById('searchResults');
    if (searchResults) {
        searchResults.style.display = 'none';
        searchResults.innerHTML = '';
    }
    
    // Очищаем поле поиска
    const searchInput = document.getElementById('searchInput');
    if (searchInput) {
        searchInput.value = '';
    }
    
    // Убираем активный класс со всех вкладок
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    
    // Активируем выбранную вкладку и показываем соответствующий контент
    if (tab === 'friends') {
        document.querySelector('.tab:nth-child(1)').classList.add('active');
        document.getElementById('usersList').style.display = 'block';
        loadUsers();
    } else if (tab === 'search') {
        document.querySelector('.tab:nth-child(2)').classList.add('active');
        document.getElementById('searchContainer').style.display = 'block';
        
        // Фокусируемся на поле ввода после небольшой задержки
        setTimeout(() => {
            if (searchInput) {
                searchInput.focus();
                console.log('Search input focused');
            }
        }, 100);
    } else if (tab === 'requests') {
        document.querySelector('.tab:nth-child(3)').classList.add('active');
        document.getElementById('friendRequestsContainer').style.display = 'block';
        loadFriendRequests();
    }
}

document.addEventListener('click', (e) => {
    const searchContainer = document.getElementById('searchContainer');
    const searchResults = document.getElementById('searchResults');
    
    if (searchResults && searchResults.style.display === 'block' && 
        !e.target.closest('#searchContainer') && 
        !e.target.closest('#searchResults')) {
        searchResults.style.display = 'none';
    }
});
function updateOnlineUsers(users) {
    // This would update the online status in the UI
}

function handleUserStatusChange(data) {
    // Update specific user's status
    if (selectedUser && selectedUser.id === data.userId) {
        selectedUser.isOnline = data.isOnline;
        document.getElementById('chatUserStatusText').textContent = data.isOnline ? 'online' : 'offline';
        document.getElementById('chatUserStatus').className = `online-status ${data.isOnline ? 'online' : 'offline'}`;
        document.getElementById('callButton').disabled = !data.isOnline;
    }
}

// Image and file handling
function handleImageUpload(event) {
    const file = event.target.files[0];
    if (!file || !selectedUser) return;
    
    // No size or type restrictions
    const reader = new FileReader();
    reader.onload = function(e) {
        // Send image as base64
        socket.emit('private_message', {
            to: selectedUser.id,
            message: e.target.result,
            from: currentUser.id,
            type: 'image'
        });
    };
    reader.onerror = function(error) {
        console.error('Error reading file:', error);
        showNotification('Ошибка при чтении файла', 'error');
    };
    reader.readAsDataURL(file);
    
    // Reset input
    event.target.value = '';
}

function handleFileUpload(event) {
    const file = event.target.files[0];
    if (!file || !selectedUser) return;
    
    // No size restrictions
    const reader = new FileReader();
    reader.onload = function(e) {
        // Send file as base64
        socket.emit('private_message', {
            to: selectedUser.id,
            message: e.target.result,
            from: currentUser.id,
            type: 'file',
            fileName: file.name,
            fileSize: file.size
        });
    };
    reader.onerror = function(error) {
        console.error('Error reading file:', error);
        showNotification('Ошибка при чтении файла', 'error');
    };
    reader.readAsDataURL(file);
    
    // Reset input
    event.target.value = '';
}

function previewImage(src) {
    document.getElementById('previewImage').src = src;
    document.getElementById('imagePreviewModal').style.display = 'flex';
}

function closeImagePreview() {
    document.getElementById('imagePreviewModal').style.display = 'none';
}

// Chat management functions
function clearChat() {
    if (!selectedUser || !confirm('Очистить всю переписку с этим пользователем?')) {
        return;
    }
    
    const messagesContainer = document.getElementById('messages');
    messagesContainer.innerHTML = '<div style="text-align: center; color: var(--text-light); margin-top: 20px;">Начните общение с этим пользователем</div>';
    currentChatMessages = [];
    
    // Here you would typically send a request to the server to clear the chat history
    showNotification('Чат очищен', 'success');
}

function deleteMessage(messageId) {
    if (!confirm('Удалить это сообщение?')) {
        return;
    }
    
    // Remove from local array
    currentChatMessages = currentChatMessages.filter(msg => msg.id !== messageId);
    
    // Remove from UI
    const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
    if (messageElement) {
        messageElement.remove();
    }
    
    // Send to server to delete from database
    socket.emit('delete_message', {
        messageId: messageId,
        from: currentUser.id,
        to: selectedUser.id
    });
    
    showNotification('Сообщение удалено', 'success');
}

function handleMessageDeleted(data) {
    const messageElement = document.querySelector(`[data-message-id="${data.messageId}"]`);
    if (messageElement) {
        messageElement.remove();
    }
    
    // Remove from local array
    currentChatMessages = currentChatMessages.filter(msg => msg.id !== data.messageId);
}

// Settings functions
function openSettings() {
    document.getElementById('settingsModal').style.display = 'flex';
}

function closeSettings() {
    document.getElementById('settingsModal').style.display = 'none';
    saveUserSettings();
}

function loadUserSettings() {
    if (currentUser.settings) {
        // Load theme
        if (currentUser.settings.theme) {
            document.getElementById('themeSelect').value = currentUser.settings.theme;
            applyTheme(currentUser.settings.theme);
        }
        
        // Load notifications
        if (currentUser.settings.notifications !== undefined) {
            document.getElementById('notificationsToggle').checked = currentUser.settings.notifications;
        }
        
        // Load device settings
        if (currentUser.settings.audioDevice) {
            document.getElementById('microphoneSelect').value = currentUser.settings.audioDevice;
        }
        if (currentUser.settings.videoDevice) {
            document.getElementById('cameraSelect').value = currentUser.settings.videoDevice;
        }
        if (currentUser.settings.audioOutput) {
            document.getElementById('audioOutputSelect').value = currentUser.settings.audioOutput;
        }
    }
    
    // Load available devices
    loadDevices();
}

async function loadDevices() {
    try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const audioInputs = devices.filter(device => device.kind === 'audioinput');
        const videoInputs = devices.filter(device => device.kind === 'videoinput');
        const audioOutputs = devices.filter(device => device.kind === 'audiooutput');
        
        const microphoneSelect = document.getElementById('microphoneSelect');
        const cameraSelect = document.getElementById('cameraSelect');
        const audioOutputSelect = document.getElementById('audioOutputSelect');
        
        // Clear existing options (except default)
        while (microphoneSelect.options.length > 1) microphoneSelect.remove(1);
        while (cameraSelect.options.length > 1) cameraSelect.remove(1);
        while (audioOutputSelect.options.length > 1) audioOutputSelect.remove(1);
        
        // Populate microphone options
        audioInputs.forEach(device => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.textContent = device.label || `Микрофон ${microphoneSelect.options.length}`;
            microphoneSelect.appendChild(option);
        });
        
        // Populate camera options
        videoInputs.forEach(device => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.textContent = device.label || `Камера ${cameraSelect.options.length}`;
            cameraSelect.appendChild(option);
        });
        
        // Populate audio output options
        audioOutputs.forEach(device => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.textContent = device.label || `Наушники ${audioOutputSelect.options.length}`;
            audioOutputSelect.appendChild(option);
        });
    } catch (error) {
        console.error('Error loading devices:', error);
    }
}

async function requestMediaPermissions() {
    try {
        // Запрашиваем разрешения с улучшенной обработкой ошибок
        const stream = await navigator.mediaDevices.getUserMedia({ 
            audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true
            }, 
            video: false // Сначала только аудио
        });
        
        // Проверяем, что у нас есть аудио-треки
        const audioTracks = stream.getAudioTracks();
        if (audioTracks.length === 0) {
            throw new Error('No audio tracks available');
        }
        
        // Останавливаем стрим после проверки
        stream.getTracks().forEach(track => track.stop());
        
        mediaPermissionsGranted = true;
        showNotification('✅ Разрешения на доступ к микрофону получены!', 'success');
        
        // Теперь запрашиваем видео разрешения
        try {
            const videoStream = await navigator.mediaDevices.getUserMedia({ video: true });
            videoStream.getTracks().forEach(track => track.stop());
            showNotification('✅ Разрешения на доступ к камере получены!', 'success');
        } catch (videoError) {
            console.log('Video permissions not granted, continuing without video');
            showNotification('⚠️ Доступ к камере не предоставлен. Звонки будут только аудио.', 'warning');
        }
        
        // Обновляем список устройств
        await loadDevices();
        
    } catch (error) {
        console.error('Error requesting media permissions:', error);
        let errorMessage = '❌ Не удалось получить разрешения на доступ к медиа-устройствам. ';
        
        if (error.name === 'NotAllowedError') {
            errorMessage += 'Пожалуйста, разрешите доступ к микрофону и камере в настройках браузера. ';
            errorMessage += 'Нажмите на значок 🔒 в адресной строке и разрешите доступ.';
        } else if (error.name === 'NotFoundError') {
            errorMessage += 'Микрофон не найден. Убедитесь, что микрофон подключен.';
        } else if (error.name === 'NotReadableError') {
            errorMessage += 'Не удалось получить доступ к микрофону. Возможно, он уже используется другим приложением.';
        } else if (error.name === 'OverconstrainedError') {
            errorMessage += 'Требуемые настройки микрофона не поддерживаются.';
        } else {
            errorMessage += 'Проверьте настройки разрешений браузера.';
        }
        
        showNotification(errorMessage, 'error');
        
        // Показываем подробное руководство
        showDetailedPermissionGuide();
    }
}

function showDetailedPermissionGuide() {
    const guide = `
        <div class="permission-guide">
            <h4>📋 Подробное руководство по разрешениям:</h4>
            <ol class="permission-steps">
                <li><strong>Chrome/Edge:</strong> Нажмите на значок 🔒 слева от адреса → "Настройки сайта" → Разрешите "Микрофон" и "Камеру"</li>
                <li><strong>Firefox:</strong> Нажмите на значок 🔒 в адресной строке → Права доступа → Разрешите "Доступ к камере" и "Доступ к микрофону"</li>
                <li><strong>Проверьте системные настройки:</strong> Убедитесь, что браузер имеет доступ к микрофону в настройках Windows/Mac</li>
                <li><strong>Перезагрузите страницу</strong> после изменения настроек</li>
            </ol>
            <button onclick="retryPermissions()" class="add-friends-btn" style="width: 100%; margin-top: 10px;">
                🔄 Повторить запрос разрешений
            </button>
        </div>
    `;
    
    // Добавляем руководство в модальное окно настроек
    const settingsBody = document.querySelector('#settingsModal .modal-body');
    const existingGuide = settingsBody.querySelector('.permission-guide');
    if (existingGuide) {
        existingGuide.remove();
    }
    settingsBody.insertAdjacentHTML('beforeend', guide);
}

function retryPermissions() {
    requestMediaPermissions();
}
function updateSearchResultStatus(username, status) {
    const searchResults = document.getElementById('searchResults');
    if (!searchResults) return;
    
    const userItems = searchResults.querySelectorAll('.user-item');
    userItems.forEach(item => {
        const userName = item.querySelector('.user-name-small').textContent;
        if (userName === username) {
            const actionElement = item.querySelector('.add-friend-btn') || item.querySelector('.friend-status');
            if (actionElement) {
                if (status === 'pending') {
                    actionElement.outerHTML = '<div class="friend-status" style="color: var(--warning-color);"><i class="fas fa-clock"></i> Заявка отправлена</div>';
                } else if (status === 'friend') {
                    actionElement.outerHTML = '<div class="friend-status"><i class="fas fa-check"></i> Друг</div>';
                }
            }
        }
    });
}
function saveUserSettings() {
    const settings = {
        theme: document.getElementById('themeSelect').value,
        notifications: document.getElementById('notificationsToggle').checked,
        audioDevice: document.getElementById('microphoneSelect').value,
        videoDevice: document.getElementById('cameraSelect').value,
        audioOutput: document.getElementById('audioOutputSelect').value,
        avatar: currentUser.settings.avatar,
        avatarType: currentUser.settings.avatarType
    };
    
    // Apply theme immediately
    applyTheme(settings.theme);
    
    // Save to server
    fetch(`/api/users/${currentUser.id}/settings`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': authToken
        },
        body: JSON.stringify({ settings })
    }).then(response => {
        if (response.ok) {
            // Update local user data
            currentUser.settings = { ...currentUser.settings, ...settings };
            sessionStorage.setItem('currentUser', JSON.stringify(currentUser));
            localStorage.setItem('theme', settings.theme); // Сохраняем тему в localStorage
            showNotification('Настройки сохранены', 'success');
        }
    });
}
function applyTheme(theme) {
    document.body.setAttribute('data-theme', theme);
}

// Call functionality with enhanced features
async function startCall() {
    if (!selectedUser || !selectedUser.isOnline) {
        showNotification('Пользователь не в сети', 'error');
        return;
    }
    
    console.log('Starting call to:', selectedUser.id);
    
    try {
        // Request media permissions
        const stream = await navigator.mediaDevices.getUserMedia({
            audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true
            },
            video: true
        });
        
        localStream = stream;
        console.log('Media stream obtained');
        
        // Enhanced configuration with multiple STUN servers
        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' }
            ],
            iceCandidatePoolSize: 10
        };
        
        // Create new peer connection
        peerConnection = new RTCPeerConnection(configuration);
        console.log('Peer connection created');
        
        // Add local stream tracks
        localStream.getTracks().forEach(track => {
            peerConnection.addTrack(track, localStream);
            console.log('Added track:', track.kind);
        });
        
        // Set up event handlers
        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                console.log('Sending ICE candidate');
                socket.emit('ice_candidate', {
                    to: selectedUser.id,
                    candidate: event.candidate
                });
            }
        };
        
        peerConnection.ontrack = (event) => {
            console.log('Received remote track');
            const remoteVideo = document.getElementById('remoteVideo');
            if (event.streams && event.streams[0]) {
                remoteVideo.srcObject = event.streams[0];
                
                // Setup audio analysis for speech detection
                setupAudioAnalysis(event.streams[0]);
            }
        };
        
        peerConnection.onconnectionstatechange = () => {
            console.log('Connection state:', peerConnection.connectionState);
            const statusElement = document.getElementById('callStatus');
            
            switch (peerConnection.connectionState) {
                case 'connected':
                    statusElement.textContent = 'Разговор активен';
                    isCallActive = true;
                    showNotification('Соединение установлено', 'success');
                    break;
                case 'disconnected':
                    statusElement.textContent = 'Соединение прервано';
                    break;
                case 'failed':
                    statusElement.textContent = 'Ошибка соединения';
                    showNotification('Ошибка соединения', 'error');
                    endCall();
                    break;
                case 'closed':
                    statusElement.textContent = 'Звонок завершен';
                    endCall();
                    break;
            }
        };
        
        // Create and set local description
        const offer = await peerConnection.createOffer({
            offerToReceiveAudio: true,
            offerToReceiveVideo: true
        });
        
        await peerConnection.setLocalDescription(offer);
        console.log('Local description set');
        
        // Send offer to the other user
        socket.emit('call_user', {
            to: selectedUser.id,
            from: currentUser.id,
            offer: offer
        });
        
        // Show call interface
        document.getElementById('callModal').style.display = 'flex';
        document.getElementById('callUserInfo').textContent = `Звонок ${selectedUser.username}`;
        document.getElementById('callStatus').textContent = 'Установка соединения...';
        
        // Setup local video
        const localVideo = document.getElementById('localVideo');
        localVideo.srcObject = localStream;
        
        // Reset call controls
        isMicOn = true;
        isCameraOn = true;
        isScreenSharing = false;
        updateCallControls();
        
        currentCall = {
            to: selectedUser.id,
            from: currentUser.id
        };
        
        console.log('Call initiated successfully');
        
    } catch (error) {
        console.error('Error starting call:', error);
        let errorMessage = 'Ошибка при запуске звонка: ';
        
        if (error.name === 'NotAllowedError') {
            errorMessage += 'Доступ к микрофону запрещен. Разрешите доступ в настройках браузера.';
        } else if (error.name === 'NotFoundError') {
            errorMessage += 'Микрофон не найден.';
        } else if (error.name === 'NotReadableError') {
            errorMessage += 'Микрофон недоступен. Возможно, используется другим приложением.';
        } else {
            errorMessage += error.message;
        }
        
        showNotification(errorMessage, 'error');
        
        // Clean up on error
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
        }
        if (peerConnection) {
            peerConnection.close();
            peerConnection = null;
        }
    }
}

function handleIncomingCall(data) {
    currentCall = data;
    isIncomingCall = true;
    
    document.getElementById('incomingCallModal').style.display = 'flex';
    document.getElementById('incomingCallUserInfo').textContent = `Входящий звонок от пользователя`;
    document.getElementById('incomingCallStatus').textContent = 'Вам звонят...';
}

async function acceptCall() {
    if (!currentCall) {
        console.error('No current call to accept');
        return;
    }
    
    console.log('Accepting call from:', currentCall.from);
    
    try {
        // Request media permissions
        const stream = await navigator.mediaDevices.getUserMedia({
            audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true
            },
            video: true
        });
        
        localStream = stream;
        
        // Configuration
        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ],
            iceCandidatePoolSize: 10
        };
        
        // Create peer connection
        peerConnection = new RTCPeerConnection(configuration);
        
        // Add local stream
        localStream.getTracks().forEach(track => {
            peerConnection.addTrack(track, localStream);
        });
        
        // Set up event handlers
        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                socket.emit('ice_candidate', {
                    to: currentCall.from,
                    candidate: event.candidate
                });
            }
        };
        
        peerConnection.ontrack = (event) => {
            console.log('Received remote track in accept');
            const remoteVideo = document.getElementById('remoteVideo');
            if (event.streams && event.streams[0]) {
                remoteVideo.srcObject = event.streams[0];
                
                // Setup audio analysis for speech detection
                setupAudioAnalysis(event.streams[0]);
            }
        };
        
        peerConnection.onconnectionstatechange = () => {
            console.log('Connection state (accept):', peerConnection.connectionState);
            const statusElement = document.getElementById('callStatus');
            
            switch (peerConnection.connectionState) {
                case 'connected':
                    statusElement.textContent = 'Разговор активен';
                    isCallActive = true;
                    showNotification('Соединение установлено', 'success');
                    break;
                case 'failed':
                    statusElement.textContent = 'Ошибка соединения';
                    showNotification('Ошибка соединения', 'error');
                    endCall();
                    break;
                case 'closed':
                    endCall();
                    break;
            }
        };
        
        // Set remote description and create answer
        await peerConnection.setRemoteDescription(currentCall.offer);
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        
        // Send answer
        socket.emit('call_accepted', {
            to: currentCall.from,
            answer: answer
        });
        
        // Update UI
        document.getElementById('incomingCallModal').style.display = 'none';
        document.getElementById('callModal').style.display = 'flex';
        document.getElementById('callUserInfo').textContent = `Разговор с пользователем`;
        document.getElementById('callStatus').textContent = 'Установка соединения...';
        
        // Setup local video
        const localVideo = document.getElementById('localVideo');
        localVideo.srcObject = localStream;
        
        // Reset controls
        isMicOn = true;
        isCameraOn = true;
        isScreenSharing = false;
        updateCallControls();
        
        isIncomingCall = false;
        console.log('Call accepted successfully');
        
    } catch (error) {
        console.error('Error accepting call:', error);
        showNotification('Ошибка при принятии звонка: ' + error.message, 'error');
        
        // Reject call on error
        socket.emit('call_rejected', { to: currentCall.from });
        endCall();
    }
}

function setupAudioAnalysis(stream) {
    try {
        // Create audio context
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        microphone = audioContext.createMediaStreamSource(stream);
        javascriptNode = audioContext.createScriptProcessor(2048, 1, 1);
        
        analyser.smoothingTimeConstant = 0.8;
        analyser.fftSize = 1024;
        
        microphone.connect(analyser);
        analyser.connect(javascriptNode);
        javascriptNode.connect(audioContext.destination);
        
        javascriptNode.onaudioprocess = function() {
            const array = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(array);
            
            let values = 0;
            const length = array.length;
            
            for (let i = 0; i < length; i++) {
                values += array[i];
            }
            
            const average = values / length;
            
            // Update speaking indicator
            const speakingIndicator = document.getElementById('speakingIndicator');
            if (speakingIndicator) {
                if (average > 50) { // Threshold for speaking
                    if (!isSpeaking) {
                        isSpeaking = true;
                        speakingIndicator.style.display = 'block';
                    }
                } else {
                    if (isSpeaking) {
                        isSpeaking = false;
                        speakingIndicator.style.display = 'none';
                    }
                }
            }
        };
    } catch (error) {
        console.error('Error setting up audio analysis:', error);
    }
}

function updateCallControls() {
    const muteBtn = document.getElementById('muteBtn');
    const videoBtn = document.getElementById('videoBtn');
    const screenShareBtn = document.getElementById('screenShareBtn');
    
    if (muteBtn) {
        muteBtn.classList.toggle('active', isMicOn);
        muteBtn.innerHTML = isMicOn ? '<i class="fas fa-microphone"></i>' : '<i class="fas fa-microphone-slash"></i>';
    }
    
    if (videoBtn) {
        videoBtn.classList.toggle('active', isCameraOn);
        videoBtn.innerHTML = isCameraOn ? '<i class="fas fa-video"></i>' : '<i class="fas fa-video-slash"></i>';
    }
    
    if (screenShareBtn) {
        screenShareBtn.classList.toggle('active', isScreenSharing);
        screenShareBtn.innerHTML = isScreenSharing ? '<i class="fas fa-stop"></i>' : '<i class="fas fa-desktop"></i>';
    }
}
document.addEventListener('DOMContentLoaded', function() {
    // Добавьте этот обработчик после других event listeners
    const avatarUpload = document.getElementById('avatarUpload');
    if (avatarUpload) {
        avatarUpload.addEventListener('change', handleAvatarUpload);
    }
});

function handleCallAccepted(data) {
    try {
        if (!peerConnection) {
            console.error('No peer connection when trying to set remote description');
            return;
        }
        
        peerConnection.setRemoteDescription(data.answer)
            .then(() => {
                document.getElementById('callStatus').textContent = 'Разговор активен';
                isCallActive = true;
                isIncomingCall = false;
                
                // Initialize avatar visibility
                updateAvatarVisibility();
                
                console.log('Remote description set successfully');
            })
            .catch(error => {
                console.error('Error setting remote description:', error);
                showNotification('Ошибка при установке соединения', 'error');
            });
    } catch (error) {
        console.error('Error in handleCallAccepted:', error);
        showNotification('Ошибка при установке соединения', 'error');
    }
}
function rejectCall() {
    if (currentCall) {
        socket.emit('call_rejected', { to: currentCall.from });
    }
    endCall();
    document.getElementById('incomingCallModal').style.display = 'none';
}

function handleCallRejected() {
    showNotification('Звонок отклонен', 'warning');
    endCall();
}

function handleCallEnded() {
    showNotification('Собеседник завершил звонок', 'warning');
    endCall();
}

function handleIceCandidate(data) {
    if (peerConnection && data.candidate) {
        peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate))
            .catch(error => console.error('Error adding ICE candidate:', error));
    }
}

function toggleMic() {
    if (!localStream) {
        showNotification('Микрофон не доступен', 'warning');
        return;
    }
    const audioTracks = localStream.getAudioTracks();
    audioTracks.forEach(track => {
        track.enabled = !track.enabled;
    });
    isMicOn = !isMicOn;
    updateCallControls();
}

function toggleCamera() {
    if (!localStream) {
        showNotification('Камера не доступна', 'warning');
        return;
    }
    
    const videoTracks = localStream.getVideoTracks();
    videoTracks.forEach(track => {
        track.enabled = !track.enabled;
    });
    isCameraOn = !isCameraOn;
    
    // Update avatar visibility based on camera state
    updateAvatarVisibility();
    updateCallControls();
}


async function toggleScreenShare() {
    if (!peerConnection) {
        showNotification('Нет активного звонка', 'warning');
        return;
    }
    
    try {
        if (!isScreenSharing) {
            // Start screen sharing
            const screenStream = await navigator.mediaDevices.getDisplayMedia({
                video: true,
                audio: true
            });
            
            // Replace video track
            const videoTrack = screenStream.getVideoTracks()[0];
            const sender = peerConnection.getSenders().find(s => 
                s.track && s.track.kind === 'video'
            );
            
            if (sender) {
                await sender.replaceTrack(videoTrack);
            }
            
            // Update local video
            const localVideo = document.getElementById('localVideo');
            localVideo.srcObject = screenStream;
            
            isScreenSharing = true;
            
            // Update avatar visibility
            updateAvatarVisibility();
            
            // Handle when user stops screen sharing
            videoTrack.onended = () => {
                toggleScreenShare();
            };
            
        } else {
            // Stop screen sharing and revert to camera
            const cameraStream = await navigator.mediaDevices.getUserMedia({ video: true });
            const videoTrack = cameraStream.getVideoTracks()[0];
            
            const sender = peerConnection.getSenders().find(s => 
                s.track && s.track.kind === 'video'
            );
            
            if (sender) {
                await sender.replaceTrack(videoTrack);
            }
            
            // Update local video
            const localVideo = document.getElementById('localVideo');
            localVideo.srcObject = cameraStream;
            
            // Stop the screen stream
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
            localStream = cameraStream;
            
            isScreenSharing = false;
            
            // Update avatar visibility
            updateAvatarVisibility();
        }
        
        updateCallControls();
        
    } catch (error) {
        console.error('Error toggling screen share:', error);
        showNotification('Ошибка при демонстрации экрана', 'error');
    }
}
function formatMessageDate(timestamp) {
    const messageDate = new Date(timestamp);
    const today = new Date();
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    
    // Проверяем, сегодня ли сообщение
    if (messageDate.toDateString() === today.toDateString()) {
        return 'Сегодня';
    }
    // Проверяем, вчера ли сообщение
    else if (messageDate.toDateString() === yesterday.toDateString()) {
        return 'Вчера';
    }
    // Проверяем, на этой ли неделе
    else if (messageDate > new Date(today.setDate(today.getDate() - 7))) {
        const days = ['Воскресенье', 'Понедельник', 'Вторник', 'Среда', 'Четверг', 'Пятница', 'Суббота'];
        return days[messageDate.getDay()];
    }
    // Иначе показываем полную дату
    else {
        return messageDate.toLocaleDateString('ru-RU', {
            day: 'numeric',
            month: 'long',
            year: 'numeric'
        });
    }
}
function shouldShowDateSeparator(prevMessage, currentMessage) {
    if (!prevMessage) return true;
    
    const prevDate = new Date(prevMessage.timestamp);
    const currentDate = new Date(currentMessage.timestamp);
    
    // Показываем разделитель, если даты разные
    return prevDate.toDateString() !== currentDate.toDateString();
}
function createDateSeparator(timestamp) {
    const separator = document.createElement('div');
    separator.className = 'date-separator';
    separator.innerHTML = `<span>${formatMessageDate(timestamp)}</span>`;
    return separator;
}
function updateAvatarVisibility() {
    const localVideo = document.getElementById('localVideo');
    const videoOverlay = document.querySelector('.video-overlay');
    
    if (!localVideo || !videoOverlay) return;
    
    // Check if video is active (camera or screen share)
    const videoTracks = localVideo.srcObject ? localVideo.srcObject.getVideoTracks() : [];
    const hasActiveVideo = videoTracks.some(track => track.enabled && track.readyState === 'live');
    
    // Show avatar overlay only if there's no active video AND screen sharing is not active
    if (hasActiveVideo || isScreenSharing) {
        videoOverlay.style.display = 'none';
        console.log('Hiding avatar - video active or screen sharing');
    } else {
        videoOverlay.style.display = 'flex';
        console.log('Showing avatar - no video or screen sharing');
        
        // Update the avatar in the overlay
        const remoteUserAvatar = document.getElementById('remoteUserAvatar');
        if (remoteUserAvatar && selectedUser) {
            remoteUserAvatar.textContent = selectedUser.username.charAt(0).toUpperCase();
        }
    }
}
function updateLocalVolume() {
    localVolume = document.getElementById('localVolume').value;
    if (localStream) {
        const audioTracks = localStream.getAudioTracks();
        // Note: Volume control for local stream is not directly available in WebRTC
        // This would typically be handled on the receiving end
    }
}

function updateRemoteVolume() {
    remoteVolume = document.getElementById('remoteVolume').value;
    const remoteVideo = document.getElementById('remoteVideo');
    if (remoteVideo) {
        remoteVideo.volume = remoteVolume;
    }
}

// Minimized call functions
function minimizeCall() {
    minimizedCall = true;
    document.getElementById('callModal').style.display = 'none';
    document.getElementById('minimizedCall').style.display = 'flex';
}

function maximizeCall() {
    minimizedCall = false;
    document.getElementById('minimizedCall').style.display = 'none';
    document.getElementById('callModal').style.display = 'flex';
}

function endCall() {
    console.log('Ending call...');
    
    // Clean up audio analysis
    if (javascriptNode) {
        javascriptNode.disconnect();
        javascriptNode = null;
    }
    if (analyser) {
        analyser.disconnect();
        analyser = null;
    }
    if (microphone) {
        microphone.disconnect();
        microphone = null;
    }
    if (audioContext) {
        audioContext.close();
        audioContext = null;
    }
    
    // Stop all media tracks
    if (localStream) {
        localStream.getTracks().forEach(track => {
            track.stop();
            track.enabled = false;
        });
        localStream = null;
    }
    
    // Close peer connection
    if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
    }
    
    // Notify other user if we're the one ending the call
    if (currentCall && !isIncomingCall && selectedUser) {
        socket.emit('end_call', { to: selectedUser.id });
    }
    
    // Hide all call-related modals
    document.getElementById('callModal').style.display = 'none';
    document.getElementById('incomingCallModal').style.display = 'none';
    document.getElementById('minimizedCall').style.display = 'none';
    
    // Reset call state
    currentCall = null;
    isIncomingCall = false;
    isCallActive = false;
    minimizedCall = false;
    isScreenSharing = false;
    isSpeaking = false;
    
    // Reset video elements
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    if (localVideo) {
        localVideo.srcObject = null;
    }
    if (remoteVideo) {
        remoteVideo.srcObject = null;
    }
    
    // Hide speaking indicators
    const localSpeakingIndicator = document.getElementById('localSpeakingIndicator');
    const remoteSpeakingIndicator = document.getElementById('remoteSpeakingIndicator');
    if (localSpeakingIndicator) localSpeakingIndicator.style.display = 'none';
    if (remoteSpeakingIndicator) remoteSpeakingIndicator.style.display = 'none';
    
    // Reset call controls
    isMicOn = true;
    isCameraOn = true;
    updateCallControls();
    
    console.log('Call ended completely');
}

// Utility functions
function autoResize(textarea) {
    textarea.style.height = 'auto';
    textarea.style.height = Math.min(textarea.scrollHeight, 100) + 'px';
}

function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

function showNotification(message, type = 'info') {
    // Remove existing notifications first
    document.querySelectorAll('.notification').forEach(notification => {
        notification.remove();
    });
    
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    
    document.body.appendChild(notification);
    
    // Auto remove after 4 seconds
    setTimeout(() => {
        if (notification.parentNode) {
            notification.remove();
        }
    }, 4000);
}

function logout() {
    // Clear all auth data
    sessionStorage.removeItem('authToken');
    sessionStorage.removeItem('currentUser');
    
    // Disconnect socket
    if (socket) {
        socket.disconnect();
    }
    
    // Redirect to login
    window.location.href = '/login';
}
    </script>
</body>
</html>